// Generated by the protocol buffer compiler.  DO NOT EDIT!

#ifndef PROTOBUF_netmonlog_2eproto__INCLUDED
#define PROTOBUF_netmonlog_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>

namespace netmon {

class KNetMonLogHeader;
class IPLOG_EXTRADATA;
class IPLOG_EXTRADATA_tagTCP_DATA;
class IPLOG_EXTRADATA_tagUDP_DATA;
class IPLOG_EXTRADATA_tagICMP_DATA;
class IPLOG_EXTRADATA_tagIGMP_DATA;
class KLOG_IP;
class LOG_MODULE;
class LOG_APP;
class IP_RANGE;
class PORT_RANGE;
class FILTER_IP_ADDR;
class FILTER_IP_PORT;
class LOG_APP_RULE;
class FILTERINFO_EXTRADATA;
class FILTERINFO_EXTRADATA_tagTCP_DATA;
class FILTERINFO_EXTRADATA_tagUDP_DATA;
class FILTERINFO_EXTRADATA_tagICMP_DATA;
class FILTERINFO_EXTRADATA_tagIGMP_DATA;
class FILTER_INFO;
class LOG_IP_RULE;
class LOG_ARP;
class LOG_AREA;
class LOG_AREA_AREA;
class LOG_USER_SETTING;
class LOG_DEBUG;
class LOG_UPDATE;
class LOG_SHEID;

// ===================================================================

class KNetMonLogHeader : public ::google::protobuf::Message {
 public:
  KNetMonLogHeader();
  virtual ~KNetMonLogHeader();
  
  KNetMonLogHeader(const KNetMonLogHeader& from);
  
  inline KNetMonLogHeader& operator=(const KNetMonLogHeader& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const KNetMonLogHeader& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  KNetMonLogHeader* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 m_eLogType = 1;
  inline bool has_m_elogtype() const;
  inline void clear_m_elogtype();
  inline ::google::protobuf::int32 m_elogtype() const;
  inline void set_m_elogtype(::google::protobuf::int32 value);
  
  // required uint64 m_nID = 2;
  inline bool has_m_nid() const;
  inline void clear_m_nid();
  inline ::google::protobuf::uint64 m_nid() const;
  inline void set_m_nid(::google::protobuf::uint64 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 m_elogtype_;
  ::google::protobuf::uint64 m_nid_;
  
  static const KNetMonLogHeader default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IPLOG_EXTRADATA_tagTCP_DATA : public ::google::protobuf::Message {
 public:
  IPLOG_EXTRADATA_tagTCP_DATA();
  virtual ~IPLOG_EXTRADATA_tagTCP_DATA();
  
  IPLOG_EXTRADATA_tagTCP_DATA(const IPLOG_EXTRADATA_tagTCP_DATA& from);
  
  inline IPLOG_EXTRADATA_tagTCP_DATA& operator=(const IPLOG_EXTRADATA_tagTCP_DATA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IPLOG_EXTRADATA_tagTCP_DATA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IPLOG_EXTRADATA_tagTCP_DATA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 localPort = 1;
  inline bool has_localport() const;
  inline void clear_localport();
  inline ::google::protobuf::int32 localport() const;
  inline void set_localport(::google::protobuf::int32 value);
  
  // optional int32 remotePort = 2;
  inline bool has_remoteport() const;
  inline void clear_remoteport();
  inline ::google::protobuf::int32 remoteport() const;
  inline void set_remoteport(::google::protobuf::int32 value);
  
  // optional int32 byTcpFlags = 3;
  inline bool has_bytcpflags() const;
  inline void clear_bytcpflags();
  inline ::google::protobuf::int32 bytcpflags() const;
  inline void set_bytcpflags(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 localport_;
  ::google::protobuf::int32 remoteport_;
  ::google::protobuf::int32 bytcpflags_;
  
  static const IPLOG_EXTRADATA_tagTCP_DATA default_instance_;
  static const int _offsets_[3];
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IPLOG_EXTRADATA_tagUDP_DATA : public ::google::protobuf::Message {
 public:
  IPLOG_EXTRADATA_tagUDP_DATA();
  virtual ~IPLOG_EXTRADATA_tagUDP_DATA();
  
  IPLOG_EXTRADATA_tagUDP_DATA(const IPLOG_EXTRADATA_tagUDP_DATA& from);
  
  inline IPLOG_EXTRADATA_tagUDP_DATA& operator=(const IPLOG_EXTRADATA_tagUDP_DATA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IPLOG_EXTRADATA_tagUDP_DATA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IPLOG_EXTRADATA_tagUDP_DATA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 localPort = 1;
  inline bool has_localport() const;
  inline void clear_localport();
  inline ::google::protobuf::int32 localport() const;
  inline void set_localport(::google::protobuf::int32 value);
  
  // optional int32 remotePort = 2;
  inline bool has_remoteport() const;
  inline void clear_remoteport();
  inline ::google::protobuf::int32 remoteport() const;
  inline void set_remoteport(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 localport_;
  ::google::protobuf::int32 remoteport_;
  
  static const IPLOG_EXTRADATA_tagUDP_DATA default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IPLOG_EXTRADATA_tagICMP_DATA : public ::google::protobuf::Message {
 public:
  IPLOG_EXTRADATA_tagICMP_DATA();
  virtual ~IPLOG_EXTRADATA_tagICMP_DATA();
  
  IPLOG_EXTRADATA_tagICMP_DATA(const IPLOG_EXTRADATA_tagICMP_DATA& from);
  
  inline IPLOG_EXTRADATA_tagICMP_DATA& operator=(const IPLOG_EXTRADATA_tagICMP_DATA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IPLOG_EXTRADATA_tagICMP_DATA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IPLOG_EXTRADATA_tagICMP_DATA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 byType = 1;
  inline bool has_bytype() const;
  inline void clear_bytype();
  inline ::google::protobuf::int32 bytype() const;
  inline void set_bytype(::google::protobuf::int32 value);
  
  // optional int32 byCode = 2;
  inline bool has_bycode() const;
  inline void clear_bycode();
  inline ::google::protobuf::int32 bycode() const;
  inline void set_bycode(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 bytype_;
  ::google::protobuf::int32 bycode_;
  
  static const IPLOG_EXTRADATA_tagICMP_DATA default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IPLOG_EXTRADATA_tagIGMP_DATA : public ::google::protobuf::Message {
 public:
  IPLOG_EXTRADATA_tagIGMP_DATA();
  virtual ~IPLOG_EXTRADATA_tagIGMP_DATA();
  
  IPLOG_EXTRADATA_tagIGMP_DATA(const IPLOG_EXTRADATA_tagIGMP_DATA& from);
  
  inline IPLOG_EXTRADATA_tagIGMP_DATA& operator=(const IPLOG_EXTRADATA_tagIGMP_DATA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IPLOG_EXTRADATA_tagIGMP_DATA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IPLOG_EXTRADATA_tagIGMP_DATA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 empty = 1;
  inline bool has_empty() const;
  inline void clear_empty();
  inline ::google::protobuf::int32 empty() const;
  inline void set_empty(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 empty_;
  
  static const IPLOG_EXTRADATA_tagIGMP_DATA default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IPLOG_EXTRADATA : public ::google::protobuf::Message {
 public:
  IPLOG_EXTRADATA();
  virtual ~IPLOG_EXTRADATA();
  
  IPLOG_EXTRADATA(const IPLOG_EXTRADATA& from);
  
  inline IPLOG_EXTRADATA& operator=(const IPLOG_EXTRADATA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IPLOG_EXTRADATA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IPLOG_EXTRADATA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  typedef IPLOG_EXTRADATA_tagTCP_DATA tagTCP_DATA;
  typedef IPLOG_EXTRADATA_tagUDP_DATA tagUDP_DATA;
  typedef IPLOG_EXTRADATA_tagICMP_DATA tagICMP_DATA;
  typedef IPLOG_EXTRADATA_tagIGMP_DATA tagIGMP_DATA;
  
  // accessors -------------------------------------------------------
  
  // optional .netmon.IPLOG_EXTRADATA.tagTCP_DATA TCP_DATA = 1;
  inline bool has_tcp_data() const;
  inline void clear_tcp_data();
  inline const ::netmon::IPLOG_EXTRADATA_tagTCP_DATA& tcp_data() const;
  inline ::netmon::IPLOG_EXTRADATA_tagTCP_DATA* mutable_tcp_data();
  
  // optional .netmon.IPLOG_EXTRADATA.tagUDP_DATA UDP_DATA = 2;
  inline bool has_udp_data() const;
  inline void clear_udp_data();
  inline const ::netmon::IPLOG_EXTRADATA_tagUDP_DATA& udp_data() const;
  inline ::netmon::IPLOG_EXTRADATA_tagUDP_DATA* mutable_udp_data();
  
  // optional .netmon.IPLOG_EXTRADATA.tagICMP_DATA ICMP_DATA = 3;
  inline bool has_icmp_data() const;
  inline void clear_icmp_data();
  inline const ::netmon::IPLOG_EXTRADATA_tagICMP_DATA& icmp_data() const;
  inline ::netmon::IPLOG_EXTRADATA_tagICMP_DATA* mutable_icmp_data();
  
  // optional .netmon.IPLOG_EXTRADATA.tagIGMP_DATA IGMP_DATA = 4;
  inline bool has_igmp_data() const;
  inline void clear_igmp_data();
  inline const ::netmon::IPLOG_EXTRADATA_tagIGMP_DATA& igmp_data() const;
  inline ::netmon::IPLOG_EXTRADATA_tagIGMP_DATA* mutable_igmp_data();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::netmon::IPLOG_EXTRADATA_tagTCP_DATA* tcp_data_;
  ::netmon::IPLOG_EXTRADATA_tagUDP_DATA* udp_data_;
  ::netmon::IPLOG_EXTRADATA_tagICMP_DATA* icmp_data_;
  ::netmon::IPLOG_EXTRADATA_tagIGMP_DATA* igmp_data_;
  
  static const IPLOG_EXTRADATA default_instance_;
  static const int _offsets_[4];
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class KLOG_IP : public ::google::protobuf::Message {
 public:
  KLOG_IP();
  virtual ~KLOG_IP();
  
  KLOG_IP(const KLOG_IP& from);
  
  inline KLOG_IP& operator=(const KLOG_IP& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const KLOG_IP& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  KLOG_IP* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes id = 1;
  inline bool has_id() const;
  inline void clear_id();
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline ::std::string* mutable_id();
  
  // optional int64 time = 2;
  inline bool has_time() const;
  inline void clear_time();
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional uint32 nCount = 3;
  inline bool has_ncount() const;
  inline void clear_ncount();
  inline ::google::protobuf::uint32 ncount() const;
  inline void set_ncount(::google::protobuf::uint32 value);
  
  // optional int32 byProtocolType = 4;
  inline bool has_byprotocoltype() const;
  inline void clear_byprotocoltype();
  inline ::google::protobuf::int32 byprotocoltype() const;
  inline void set_byprotocoltype(::google::protobuf::int32 value);
  
  // optional uint32 LocalAddr = 5;
  inline bool has_localaddr() const;
  inline void clear_localaddr();
  inline ::google::protobuf::uint32 localaddr() const;
  inline void set_localaddr(::google::protobuf::uint32 value);
  
  // optional uint32 RemoteAddr = 6;
  inline bool has_remoteaddr() const;
  inline void clear_remoteaddr();
  inline ::google::protobuf::uint32 remoteaddr() const;
  inline void set_remoteaddr(::google::protobuf::uint32 value);
  
  // optional int32 byDirection = 7;
  inline bool has_bydirection() const;
  inline void clear_bydirection();
  inline ::google::protobuf::int32 bydirection() const;
  inline void set_bydirection(::google::protobuf::int32 value);
  
  // optional int32 nOperation = 8;
  inline bool has_noperation() const;
  inline void clear_noperation();
  inline ::google::protobuf::int32 noperation() const;
  inline void set_noperation(::google::protobuf::int32 value);
  
  // optional uint32 nAttackType = 9;
  inline bool has_nattacktype() const;
  inline void clear_nattacktype();
  inline ::google::protobuf::uint32 nattacktype() const;
  inline void set_nattacktype(::google::protobuf::uint32 value);
  
  // optional .netmon.IPLOG_EXTRADATA ExtraInfo = 10;
  inline bool has_extrainfo() const;
  inline void clear_extrainfo();
  inline const ::netmon::IPLOG_EXTRADATA& extrainfo() const;
  inline ::netmon::IPLOG_EXTRADATA* mutable_extrainfo();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* id_;
  static const ::std::string _default_id_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::uint32 ncount_;
  ::google::protobuf::int32 byprotocoltype_;
  ::google::protobuf::uint32 localaddr_;
  ::google::protobuf::uint32 remoteaddr_;
  ::google::protobuf::int32 bydirection_;
  ::google::protobuf::int32 noperation_;
  ::google::protobuf::uint32 nattacktype_;
  ::netmon::IPLOG_EXTRADATA* extrainfo_;
  
  static const KLOG_IP default_instance_;
  static const int _offsets_[10];
  
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LOG_MODULE : public ::google::protobuf::Message {
 public:
  LOG_MODULE();
  virtual ~LOG_MODULE();
  
  LOG_MODULE(const LOG_MODULE& from);
  
  inline LOG_MODULE& operator=(const LOG_MODULE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LOG_MODULE& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LOG_MODULE* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline ::std::string* mutable_userid();
  
  // optional bytes modulePath = 2;
  inline bool has_modulepath() const;
  inline void clear_modulepath();
  inline const ::std::string& modulepath() const;
  inline void set_modulepath(const ::std::string& value);
  inline void set_modulepath(const char* value);
  inline ::std::string* mutable_modulepath();
  
  // optional uint32 trustModle = 3;
  inline bool has_trustmodle() const;
  inline void clear_trustmodle();
  inline ::google::protobuf::uint32 trustmodle() const;
  inline void set_trustmodle(::google::protobuf::uint32 value);
  
  // optional uint32 userModle = 4;
  inline bool has_usermodle() const;
  inline void clear_usermodle();
  inline ::google::protobuf::uint32 usermodle() const;
  inline void set_usermodle(::google::protobuf::uint32 value);
  
  // optional uint32 popRes = 5;
  inline bool has_popres() const;
  inline void clear_popres();
  inline ::google::protobuf::uint32 popres() const;
  inline void set_popres(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* userid_;
  static const ::std::string _default_userid_;
  ::std::string* modulepath_;
  static const ::std::string _default_modulepath_;
  ::google::protobuf::uint32 trustmodle_;
  ::google::protobuf::uint32 usermodle_;
  ::google::protobuf::uint32 popres_;
  
  static const LOG_MODULE default_instance_;
  static const int _offsets_[5];
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LOG_APP : public ::google::protobuf::Message {
 public:
  LOG_APP();
  virtual ~LOG_APP();
  
  LOG_APP(const LOG_APP& from);
  
  inline LOG_APP& operator=(const LOG_APP& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LOG_APP& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LOG_APP* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 eFlag = 1;
  inline bool has_eflag() const;
  inline void clear_eflag();
  inline ::google::protobuf::int32 eflag() const;
  inline void set_eflag(::google::protobuf::int32 value);
  
  // optional uint32 dwRemoteAddress = 2;
  inline bool has_dwremoteaddress() const;
  inline void clear_dwremoteaddress();
  inline ::google::protobuf::uint32 dwremoteaddress() const;
  inline void set_dwremoteaddress(::google::protobuf::uint32 value);
  
  // optional uint32 dwLocalAddress = 3;
  inline bool has_dwlocaladdress() const;
  inline void clear_dwlocaladdress();
  inline ::google::protobuf::uint32 dwlocaladdress() const;
  inline void set_dwlocaladdress(::google::protobuf::uint32 value);
  
  // optional int32 wRemotePort = 4;
  inline bool has_wremoteport() const;
  inline void clear_wremoteport();
  inline ::google::protobuf::int32 wremoteport() const;
  inline void set_wremoteport(::google::protobuf::int32 value);
  
  // optional int32 wLocalPort = 5;
  inline bool has_wlocalport() const;
  inline void clear_wlocalport();
  inline ::google::protobuf::int32 wlocalport() const;
  inline void set_wlocalport(::google::protobuf::int32 value);
  
  // optional int32 nRequestType = 6;
  inline bool has_nrequesttype() const;
  inline void clear_nrequesttype();
  inline ::google::protobuf::int32 nrequesttype() const;
  inline void set_nrequesttype(::google::protobuf::int32 value);
  
  // optional int32 nRequestProtocol = 7;
  inline bool has_nrequestprotocol() const;
  inline void clear_nrequestprotocol();
  inline ::google::protobuf::int32 nrequestprotocol() const;
  inline void set_nrequestprotocol(::google::protobuf::int32 value);
  
  // optional int64 time = 8;
  inline bool has_time() const;
  inline void clear_time();
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional int32 nBehavior = 9;
  inline bool has_nbehavior() const;
  inline void clear_nbehavior();
  inline ::google::protobuf::int32 nbehavior() const;
  inline void set_nbehavior(::google::protobuf::int32 value);
  
  // optional .netmon.LOG_MODULE exeModule = 10;
  inline bool has_exemodule() const;
  inline void clear_exemodule();
  inline const ::netmon::LOG_MODULE& exemodule() const;
  inline ::netmon::LOG_MODULE* mutable_exemodule();
  
  // repeated .netmon.LOG_MODULE dllModules = 11;
  inline int dllmodules_size() const;
  inline void clear_dllmodules();
  inline const ::google::protobuf::RepeatedPtrField< ::netmon::LOG_MODULE >& dllmodules() const;
  inline ::google::protobuf::RepeatedPtrField< ::netmon::LOG_MODULE >* mutable_dllmodules();
  inline const ::netmon::LOG_MODULE& dllmodules(int index) const;
  inline ::netmon::LOG_MODULE* mutable_dllmodules(int index);
  inline ::netmon::LOG_MODULE* add_dllmodules();
  
  // optional bytes lanpath = 12;
  inline bool has_lanpath() const;
  inline void clear_lanpath();
  inline const ::std::string& lanpath() const;
  inline void set_lanpath(const ::std::string& value);
  inline void set_lanpath(const char* value);
  inline ::std::string* mutable_lanpath();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 eflag_;
  ::google::protobuf::uint32 dwremoteaddress_;
  ::google::protobuf::uint32 dwlocaladdress_;
  ::google::protobuf::int32 wremoteport_;
  ::google::protobuf::int32 wlocalport_;
  ::google::protobuf::int32 nrequesttype_;
  ::google::protobuf::int32 nrequestprotocol_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 nbehavior_;
  ::netmon::LOG_MODULE* exemodule_;
  ::google::protobuf::RepeatedPtrField< ::netmon::LOG_MODULE > dllmodules_;
  ::std::string* lanpath_;
  static const ::std::string _default_lanpath_;
  
  static const LOG_APP default_instance_;
  static const int _offsets_[12];
  
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class IP_RANGE : public ::google::protobuf::Message {
 public:
  IP_RANGE();
  virtual ~IP_RANGE();
  
  IP_RANGE(const IP_RANGE& from);
  
  inline IP_RANGE& operator=(const IP_RANGE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const IP_RANGE& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  IP_RANGE* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 addr_start = 1;
  inline bool has_addr_start() const;
  inline void clear_addr_start();
  inline ::google::protobuf::int32 addr_start() const;
  inline void set_addr_start(::google::protobuf::int32 value);
  
  // optional int32 addr_end = 2;
  inline bool has_addr_end() const;
  inline void clear_addr_end();
  inline ::google::protobuf::int32 addr_end() const;
  inline void set_addr_end(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 addr_start_;
  ::google::protobuf::int32 addr_end_;
  
  static const IP_RANGE default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class PORT_RANGE : public ::google::protobuf::Message {
 public:
  PORT_RANGE();
  virtual ~PORT_RANGE();
  
  PORT_RANGE(const PORT_RANGE& from);
  
  inline PORT_RANGE& operator=(const PORT_RANGE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const PORT_RANGE& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  PORT_RANGE* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 port_start = 1;
  inline bool has_port_start() const;
  inline void clear_port_start();
  inline ::google::protobuf::int32 port_start() const;
  inline void set_port_start(::google::protobuf::int32 value);
  
  // optional int32 port_end = 2;
  inline bool has_port_end() const;
  inline void clear_port_end();
  inline ::google::protobuf::int32 port_end() const;
  inline void set_port_end(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 port_start_;
  ::google::protobuf::int32 port_end_;
  
  static const PORT_RANGE default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class FILTER_IP_ADDR : public ::google::protobuf::Message {
 public:
  FILTER_IP_ADDR();
  virtual ~FILTER_IP_ADDR();
  
  FILTER_IP_ADDR(const FILTER_IP_ADDR& from);
  
  inline FILTER_IP_ADDR& operator=(const FILTER_IP_ADDR& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const FILTER_IP_ADDR& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  FILTER_IP_ADDR* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 addrmode = 1;
  inline bool has_addrmode() const;
  inline void clear_addrmode();
  inline ::google::protobuf::int32 addrmode() const;
  inline void set_addrmode(::google::protobuf::int32 value);
  
  // optional int32 ipaddr = 2;
  inline bool has_ipaddr() const;
  inline void clear_ipaddr();
  inline ::google::protobuf::int32 ipaddr() const;
  inline void set_ipaddr(::google::protobuf::int32 value);
  
  // optional .netmon.PORT_RANGE addrrange = 3;
  inline bool has_addrrange() const;
  inline void clear_addrrange();
  inline const ::netmon::PORT_RANGE& addrrange() const;
  inline ::netmon::PORT_RANGE* mutable_addrrange();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 addrmode_;
  ::google::protobuf::int32 ipaddr_;
  ::netmon::PORT_RANGE* addrrange_;
  
  static const FILTER_IP_ADDR default_instance_;
  static const int _offsets_[3];
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class FILTER_IP_PORT : public ::google::protobuf::Message {
 public:
  FILTER_IP_PORT();
  virtual ~FILTER_IP_PORT();
  
  FILTER_IP_PORT(const FILTER_IP_PORT& from);
  
  inline FILTER_IP_PORT& operator=(const FILTER_IP_PORT& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const FILTER_IP_PORT& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  FILTER_IP_PORT* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 addrmode = 1;
  inline bool has_addrmode() const;
  inline void clear_addrmode();
  inline ::google::protobuf::int32 addrmode() const;
  inline void set_addrmode(::google::protobuf::int32 value);
  
  // optional int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // optional .netmon.PORT_RANGE portrange = 3;
  inline bool has_portrange() const;
  inline void clear_portrange();
  inline const ::netmon::PORT_RANGE& portrange() const;
  inline ::netmon::PORT_RANGE* mutable_portrange();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 addrmode_;
  ::google::protobuf::int32 port_;
  ::netmon::PORT_RANGE* portrange_;
  
  static const FILTER_IP_PORT default_instance_;
  static const int _offsets_[3];
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LOG_APP_RULE : public ::google::protobuf::Message {
 public:
  LOG_APP_RULE();
  virtual ~LOG_APP_RULE();
  
  LOG_APP_RULE(const LOG_APP_RULE& from);
  
  inline LOG_APP_RULE& operator=(const LOG_APP_RULE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LOG_APP_RULE& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LOG_APP_RULE* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline ::std::string* mutable_userid();
  
  // optional bytes ruleid = 2;
  inline bool has_ruleid() const;
  inline void clear_ruleid();
  inline const ::std::string& ruleid() const;
  inline void set_ruleid(const ::std::string& value);
  inline void set_ruleid(const char* value);
  inline ::std::string* mutable_ruleid();
  
  // optional bytes modulepath = 3;
  inline bool has_modulepath() const;
  inline void clear_modulepath();
  inline const ::std::string& modulepath() const;
  inline void set_modulepath(const ::std::string& value);
  inline void set_modulepath(const char* value);
  inline ::std::string* mutable_modulepath();
  
  // optional bytes checksum = 4;
  inline bool has_checksum() const;
  inline void clear_checksum();
  inline const ::std::string& checksum() const;
  inline void set_checksum(const ::std::string& value);
  inline void set_checksum(const char* value);
  inline ::std::string* mutable_checksum();
  
  // repeated .netmon.FILTER_IP_PORT tcp_remote_denyports = 5;
  inline int tcp_remote_denyports_size() const;
  inline void clear_tcp_remote_denyports();
  inline const ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >& tcp_remote_denyports() const;
  inline ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >* mutable_tcp_remote_denyports();
  inline const ::netmon::FILTER_IP_PORT& tcp_remote_denyports(int index) const;
  inline ::netmon::FILTER_IP_PORT* mutable_tcp_remote_denyports(int index);
  inline ::netmon::FILTER_IP_PORT* add_tcp_remote_denyports();
  
  // repeated .netmon.FILTER_IP_PORT tcp_local_deny_ports = 6;
  inline int tcp_local_deny_ports_size() const;
  inline void clear_tcp_local_deny_ports();
  inline const ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >& tcp_local_deny_ports() const;
  inline ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >* mutable_tcp_local_deny_ports();
  inline const ::netmon::FILTER_IP_PORT& tcp_local_deny_ports(int index) const;
  inline ::netmon::FILTER_IP_PORT* mutable_tcp_local_deny_ports(int index);
  inline ::netmon::FILTER_IP_PORT* add_tcp_local_deny_ports();
  
  // repeated .netmon.FILTER_IP_PORT udp_remote_denyports = 7;
  inline int udp_remote_denyports_size() const;
  inline void clear_udp_remote_denyports();
  inline const ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >& udp_remote_denyports() const;
  inline ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >* mutable_udp_remote_denyports();
  inline const ::netmon::FILTER_IP_PORT& udp_remote_denyports(int index) const;
  inline ::netmon::FILTER_IP_PORT* mutable_udp_remote_denyports(int index);
  inline ::netmon::FILTER_IP_PORT* add_udp_remote_denyports();
  
  // repeated .netmon.FILTER_IP_PORT udp_local_deny_ports = 8;
  inline int udp_local_deny_ports_size() const;
  inline void clear_udp_local_deny_ports();
  inline const ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >& udp_local_deny_ports() const;
  inline ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >* mutable_udp_local_deny_ports();
  inline const ::netmon::FILTER_IP_PORT& udp_local_deny_ports(int index) const;
  inline ::netmon::FILTER_IP_PORT* mutable_udp_local_deny_ports(int index);
  inline ::netmon::FILTER_IP_PORT* add_udp_local_deny_ports();
  
  // optional int32 trustmode = 9;
  inline bool has_trustmode() const;
  inline void clear_trustmode();
  inline ::google::protobuf::int32 trustmode() const;
  inline void set_trustmode(::google::protobuf::int32 value);
  
  // optional int32 usermode = 10;
  inline bool has_usermode() const;
  inline void clear_usermode();
  inline ::google::protobuf::int32 usermode() const;
  inline void set_usermode(::google::protobuf::int32 value);
  
  // optional int32 eFlag = 11;
  inline bool has_eflag() const;
  inline void clear_eflag();
  inline ::google::protobuf::int32 eflag() const;
  inline void set_eflag(::google::protobuf::int32 value);
  
  // optional int64 time = 12;
  inline bool has_time() const;
  inline void clear_time();
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional int32 bDll = 13;
  inline bool has_bdll() const;
  inline void clear_bdll();
  inline ::google::protobuf::int32 bdll() const;
  inline void set_bdll(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* userid_;
  static const ::std::string _default_userid_;
  ::std::string* ruleid_;
  static const ::std::string _default_ruleid_;
  ::std::string* modulepath_;
  static const ::std::string _default_modulepath_;
  ::std::string* checksum_;
  static const ::std::string _default_checksum_;
  ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT > tcp_remote_denyports_;
  ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT > tcp_local_deny_ports_;
  ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT > udp_remote_denyports_;
  ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT > udp_local_deny_ports_;
  ::google::protobuf::int32 trustmode_;
  ::google::protobuf::int32 usermode_;
  ::google::protobuf::int32 eflag_;
  ::google::protobuf::int64 time_;
  ::google::protobuf::int32 bdll_;
  
  static const LOG_APP_RULE default_instance_;
  static const int _offsets_[13];
  
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class FILTERINFO_EXTRADATA_tagTCP_DATA : public ::google::protobuf::Message {
 public:
  FILTERINFO_EXTRADATA_tagTCP_DATA();
  virtual ~FILTERINFO_EXTRADATA_tagTCP_DATA();
  
  FILTERINFO_EXTRADATA_tagTCP_DATA(const FILTERINFO_EXTRADATA_tagTCP_DATA& from);
  
  inline FILTERINFO_EXTRADATA_tagTCP_DATA& operator=(const FILTERINFO_EXTRADATA_tagTCP_DATA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const FILTERINFO_EXTRADATA_tagTCP_DATA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  FILTERINFO_EXTRADATA_tagTCP_DATA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .netmon.FILTER_IP_PORT localPort = 1;
  inline bool has_localport() const;
  inline void clear_localport();
  inline const ::netmon::FILTER_IP_PORT& localport() const;
  inline ::netmon::FILTER_IP_PORT* mutable_localport();
  
  // optional .netmon.FILTER_IP_PORT remotePort = 2;
  inline bool has_remoteport() const;
  inline void clear_remoteport();
  inline const ::netmon::FILTER_IP_PORT& remoteport() const;
  inline ::netmon::FILTER_IP_PORT* mutable_remoteport();
  
  // optional int32 byTcpFlags = 3;
  inline bool has_bytcpflags() const;
  inline void clear_bytcpflags();
  inline ::google::protobuf::int32 bytcpflags() const;
  inline void set_bytcpflags(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::netmon::FILTER_IP_PORT* localport_;
  ::netmon::FILTER_IP_PORT* remoteport_;
  ::google::protobuf::int32 bytcpflags_;
  
  static const FILTERINFO_EXTRADATA_tagTCP_DATA default_instance_;
  static const int _offsets_[3];
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class FILTERINFO_EXTRADATA_tagUDP_DATA : public ::google::protobuf::Message {
 public:
  FILTERINFO_EXTRADATA_tagUDP_DATA();
  virtual ~FILTERINFO_EXTRADATA_tagUDP_DATA();
  
  FILTERINFO_EXTRADATA_tagUDP_DATA(const FILTERINFO_EXTRADATA_tagUDP_DATA& from);
  
  inline FILTERINFO_EXTRADATA_tagUDP_DATA& operator=(const FILTERINFO_EXTRADATA_tagUDP_DATA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const FILTERINFO_EXTRADATA_tagUDP_DATA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  FILTERINFO_EXTRADATA_tagUDP_DATA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .netmon.FILTER_IP_PORT localPort = 1;
  inline bool has_localport() const;
  inline void clear_localport();
  inline const ::netmon::FILTER_IP_PORT& localport() const;
  inline ::netmon::FILTER_IP_PORT* mutable_localport();
  
  // optional .netmon.FILTER_IP_PORT remotePort = 2;
  inline bool has_remoteport() const;
  inline void clear_remoteport();
  inline const ::netmon::FILTER_IP_PORT& remoteport() const;
  inline ::netmon::FILTER_IP_PORT* mutable_remoteport();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::netmon::FILTER_IP_PORT* localport_;
  ::netmon::FILTER_IP_PORT* remoteport_;
  
  static const FILTERINFO_EXTRADATA_tagUDP_DATA default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class FILTERINFO_EXTRADATA_tagICMP_DATA : public ::google::protobuf::Message {
 public:
  FILTERINFO_EXTRADATA_tagICMP_DATA();
  virtual ~FILTERINFO_EXTRADATA_tagICMP_DATA();
  
  FILTERINFO_EXTRADATA_tagICMP_DATA(const FILTERINFO_EXTRADATA_tagICMP_DATA& from);
  
  inline FILTERINFO_EXTRADATA_tagICMP_DATA& operator=(const FILTERINFO_EXTRADATA_tagICMP_DATA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const FILTERINFO_EXTRADATA_tagICMP_DATA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  FILTERINFO_EXTRADATA_tagICMP_DATA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 byType = 1;
  inline bool has_bytype() const;
  inline void clear_bytype();
  inline ::google::protobuf::int32 bytype() const;
  inline void set_bytype(::google::protobuf::int32 value);
  
  // optional int32 byCode = 2;
  inline bool has_bycode() const;
  inline void clear_bycode();
  inline ::google::protobuf::int32 bycode() const;
  inline void set_bycode(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 bytype_;
  ::google::protobuf::int32 bycode_;
  
  static const FILTERINFO_EXTRADATA_tagICMP_DATA default_instance_;
  static const int _offsets_[2];
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class FILTERINFO_EXTRADATA_tagIGMP_DATA : public ::google::protobuf::Message {
 public:
  FILTERINFO_EXTRADATA_tagIGMP_DATA();
  virtual ~FILTERINFO_EXTRADATA_tagIGMP_DATA();
  
  FILTERINFO_EXTRADATA_tagIGMP_DATA(const FILTERINFO_EXTRADATA_tagIGMP_DATA& from);
  
  inline FILTERINFO_EXTRADATA_tagIGMP_DATA& operator=(const FILTERINFO_EXTRADATA_tagIGMP_DATA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const FILTERINFO_EXTRADATA_tagIGMP_DATA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  FILTERINFO_EXTRADATA_tagIGMP_DATA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 empty = 1;
  inline bool has_empty() const;
  inline void clear_empty();
  inline ::google::protobuf::int32 empty() const;
  inline void set_empty(::google::protobuf::int32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 empty_;
  
  static const FILTERINFO_EXTRADATA_tagIGMP_DATA default_instance_;
  static const int _offsets_[1];
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class FILTERINFO_EXTRADATA : public ::google::protobuf::Message {
 public:
  FILTERINFO_EXTRADATA();
  virtual ~FILTERINFO_EXTRADATA();
  
  FILTERINFO_EXTRADATA(const FILTERINFO_EXTRADATA& from);
  
  inline FILTERINFO_EXTRADATA& operator=(const FILTERINFO_EXTRADATA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const FILTERINFO_EXTRADATA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  FILTERINFO_EXTRADATA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  typedef FILTERINFO_EXTRADATA_tagTCP_DATA tagTCP_DATA;
  typedef FILTERINFO_EXTRADATA_tagUDP_DATA tagUDP_DATA;
  typedef FILTERINFO_EXTRADATA_tagICMP_DATA tagICMP_DATA;
  typedef FILTERINFO_EXTRADATA_tagIGMP_DATA tagIGMP_DATA;
  
  // accessors -------------------------------------------------------
  
  // optional .netmon.FILTERINFO_EXTRADATA.tagTCP_DATA TCP_DATA = 1;
  inline bool has_tcp_data() const;
  inline void clear_tcp_data();
  inline const ::netmon::FILTERINFO_EXTRADATA_tagTCP_DATA& tcp_data() const;
  inline ::netmon::FILTERINFO_EXTRADATA_tagTCP_DATA* mutable_tcp_data();
  
  // optional .netmon.FILTERINFO_EXTRADATA.tagUDP_DATA UDP_DATA = 2;
  inline bool has_udp_data() const;
  inline void clear_udp_data();
  inline const ::netmon::FILTERINFO_EXTRADATA_tagUDP_DATA& udp_data() const;
  inline ::netmon::FILTERINFO_EXTRADATA_tagUDP_DATA* mutable_udp_data();
  
  // optional .netmon.FILTERINFO_EXTRADATA.tagICMP_DATA ICMP_DATA = 3;
  inline bool has_icmp_data() const;
  inline void clear_icmp_data();
  inline const ::netmon::FILTERINFO_EXTRADATA_tagICMP_DATA& icmp_data() const;
  inline ::netmon::FILTERINFO_EXTRADATA_tagICMP_DATA* mutable_icmp_data();
  
  // optional .netmon.FILTERINFO_EXTRADATA.tagIGMP_DATA IGMP_DATA = 4;
  inline bool has_igmp_data() const;
  inline void clear_igmp_data();
  inline const ::netmon::FILTERINFO_EXTRADATA_tagIGMP_DATA& igmp_data() const;
  inline ::netmon::FILTERINFO_EXTRADATA_tagIGMP_DATA* mutable_igmp_data();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::netmon::FILTERINFO_EXTRADATA_tagTCP_DATA* tcp_data_;
  ::netmon::FILTERINFO_EXTRADATA_tagUDP_DATA* udp_data_;
  ::netmon::FILTERINFO_EXTRADATA_tagICMP_DATA* icmp_data_;
  ::netmon::FILTERINFO_EXTRADATA_tagIGMP_DATA* igmp_data_;
  
  static const FILTERINFO_EXTRADATA default_instance_;
  static const int _offsets_[4];
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class FILTER_INFO : public ::google::protobuf::Message {
 public:
  FILTER_INFO();
  virtual ~FILTER_INFO();
  
  FILTER_INFO(const FILTER_INFO& from);
  
  inline FILTER_INFO& operator=(const FILTER_INFO& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const FILTER_INFO& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  FILTER_INFO* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 protocoltype = 1;
  inline bool has_protocoltype() const;
  inline void clear_protocoltype();
  inline ::google::protobuf::int32 protocoltype() const;
  inline void set_protocoltype(::google::protobuf::int32 value);
  
  // optional int32 direction = 2;
  inline bool has_direction() const;
  inline void clear_direction();
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);
  
  // optional int32 operation = 3;
  inline bool has_operation() const;
  inline void clear_operation();
  inline ::google::protobuf::int32 operation() const;
  inline void set_operation(::google::protobuf::int32 value);
  
  // optional .netmon.FILTER_IP_ADDR localaddr = 4;
  inline bool has_localaddr() const;
  inline void clear_localaddr();
  inline const ::netmon::FILTER_IP_ADDR& localaddr() const;
  inline ::netmon::FILTER_IP_ADDR* mutable_localaddr();
  
  // optional .netmon.FILTER_IP_ADDR remoteaddr = 5;
  inline bool has_remoteaddr() const;
  inline void clear_remoteaddr();
  inline const ::netmon::FILTER_IP_ADDR& remoteaddr() const;
  inline ::netmon::FILTER_IP_ADDR* mutable_remoteaddr();
  
  // optional .netmon.FILTERINFO_EXTRADATA externdata = 6;
  inline bool has_externdata() const;
  inline void clear_externdata();
  inline const ::netmon::FILTERINFO_EXTRADATA& externdata() const;
  inline ::netmon::FILTERINFO_EXTRADATA* mutable_externdata();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 protocoltype_;
  ::google::protobuf::int32 direction_;
  ::google::protobuf::int32 operation_;
  ::netmon::FILTER_IP_ADDR* localaddr_;
  ::netmon::FILTER_IP_ADDR* remoteaddr_;
  ::netmon::FILTERINFO_EXTRADATA* externdata_;
  
  static const FILTER_INFO default_instance_;
  static const int _offsets_[6];
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LOG_IP_RULE : public ::google::protobuf::Message {
 public:
  LOG_IP_RULE();
  virtual ~LOG_IP_RULE();
  
  LOG_IP_RULE(const LOG_IP_RULE& from);
  
  inline LOG_IP_RULE& operator=(const LOG_IP_RULE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LOG_IP_RULE& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LOG_IP_RULE* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes userid = 1;
  inline bool has_userid() const;
  inline void clear_userid();
  inline const ::std::string& userid() const;
  inline void set_userid(const ::std::string& value);
  inline void set_userid(const char* value);
  inline ::std::string* mutable_userid();
  
  // optional bytes ruleid = 2;
  inline bool has_ruleid() const;
  inline void clear_ruleid();
  inline const ::std::string& ruleid() const;
  inline void set_ruleid(const ::std::string& value);
  inline void set_ruleid(const char* value);
  inline ::std::string* mutable_ruleid();
  
  // optional bytes name = 3;
  inline bool has_name() const;
  inline void clear_name();
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline ::std::string* mutable_name();
  
  // optional int32 valid = 4;
  inline bool has_valid() const;
  inline void clear_valid();
  inline ::google::protobuf::int32 valid() const;
  inline void set_valid(::google::protobuf::int32 value);
  
  // optional .netmon.FILTER_INFO filterinfo = 5;
  inline bool has_filterinfo() const;
  inline void clear_filterinfo();
  inline const ::netmon::FILTER_INFO& filterinfo() const;
  inline ::netmon::FILTER_INFO* mutable_filterinfo();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* userid_;
  static const ::std::string _default_userid_;
  ::std::string* ruleid_;
  static const ::std::string _default_ruleid_;
  ::std::string* name_;
  static const ::std::string _default_name_;
  ::google::protobuf::int32 valid_;
  ::netmon::FILTER_INFO* filterinfo_;
  
  static const LOG_IP_RULE default_instance_;
  static const int _offsets_[5];
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LOG_ARP : public ::google::protobuf::Message {
 public:
  LOG_ARP();
  virtual ~LOG_ARP();
  
  LOG_ARP(const LOG_ARP& from);
  
  inline LOG_ARP& operator=(const LOG_ARP& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LOG_ARP& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LOG_ARP* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 count = 1;
  inline bool has_count() const;
  inline void clear_count();
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);
  
  // optional int32 block_type = 2;
  inline bool has_block_type() const;
  inline void clear_block_type();
  inline ::google::protobuf::int32 block_type() const;
  inline void set_block_type(::google::protobuf::int32 value);
  
  // optional bytes eh_destaddr = 3;
  inline bool has_eh_destaddr() const;
  inline void clear_eh_destaddr();
  inline const ::std::string& eh_destaddr() const;
  inline void set_eh_destaddr(const ::std::string& value);
  inline void set_eh_destaddr(const char* value);
  inline ::std::string* mutable_eh_destaddr();
  
  // optional bytes eh_srcaddr = 4;
  inline bool has_eh_srcaddr() const;
  inline void clear_eh_srcaddr();
  inline const ::std::string& eh_srcaddr() const;
  inline void set_eh_srcaddr(const ::std::string& value);
  inline void set_eh_srcaddr(const char* value);
  inline ::std::string* mutable_eh_srcaddr();
  
  // optional bytes arp_sender_haddr = 5;
  inline bool has_arp_sender_haddr() const;
  inline void clear_arp_sender_haddr();
  inline const ::std::string& arp_sender_haddr() const;
  inline void set_arp_sender_haddr(const ::std::string& value);
  inline void set_arp_sender_haddr(const char* value);
  inline ::std::string* mutable_arp_sender_haddr();
  
  // optional uint32 arp_sender_addr = 6;
  inline bool has_arp_sender_addr() const;
  inline void clear_arp_sender_addr();
  inline ::google::protobuf::uint32 arp_sender_addr() const;
  inline void set_arp_sender_addr(::google::protobuf::uint32 value);
  
  // optional bytes arp_target_haddr = 7;
  inline bool has_arp_target_haddr() const;
  inline void clear_arp_target_haddr();
  inline const ::std::string& arp_target_haddr() const;
  inline void set_arp_target_haddr(const ::std::string& value);
  inline void set_arp_target_haddr(const char* value);
  inline ::std::string* mutable_arp_target_haddr();
  
  // optional uint32 arp_target_addr = 8;
  inline bool has_arp_target_addr() const;
  inline void clear_arp_target_addr();
  inline ::google::protobuf::uint32 arp_target_addr() const;
  inline void set_arp_target_addr(::google::protobuf::uint32 value);
  
  // optional int64 time = 9;
  inline bool has_time() const;
  inline void clear_time();
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 count_;
  ::google::protobuf::int32 block_type_;
  ::std::string* eh_destaddr_;
  static const ::std::string _default_eh_destaddr_;
  ::std::string* eh_srcaddr_;
  static const ::std::string _default_eh_srcaddr_;
  ::std::string* arp_sender_haddr_;
  static const ::std::string _default_arp_sender_haddr_;
  ::google::protobuf::uint32 arp_sender_addr_;
  ::std::string* arp_target_haddr_;
  static const ::std::string _default_arp_target_haddr_;
  ::google::protobuf::uint32 arp_target_addr_;
  ::google::protobuf::int64 time_;
  
  static const LOG_ARP default_instance_;
  static const int _offsets_[9];
  
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LOG_AREA_AREA : public ::google::protobuf::Message {
 public:
  LOG_AREA_AREA();
  virtual ~LOG_AREA_AREA();
  
  LOG_AREA_AREA(const LOG_AREA_AREA& from);
  
  inline LOG_AREA_AREA& operator=(const LOG_AREA_AREA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LOG_AREA_AREA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LOG_AREA_AREA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes area_name = 1;
  inline bool has_area_name() const;
  inline void clear_area_name();
  inline const ::std::string& area_name() const;
  inline void set_area_name(const ::std::string& value);
  inline void set_area_name(const char* value);
  inline ::std::string* mutable_area_name();
  
  // optional uint32 area_type = 2;
  inline bool has_area_type() const;
  inline void clear_area_type();
  inline ::google::protobuf::uint32 area_type() const;
  inline void set_area_type(::google::protobuf::uint32 value);
  
  // optional bytes area_gatemac = 3;
  inline bool has_area_gatemac() const;
  inline void clear_area_gatemac();
  inline const ::std::string& area_gatemac() const;
  inline void set_area_gatemac(const ::std::string& value);
  inline void set_area_gatemac(const char* value);
  inline ::std::string* mutable_area_gatemac();
  
  // optional uint32 area_gateip = 4;
  inline bool has_area_gateip() const;
  inline void clear_area_gateip();
  inline ::google::protobuf::uint32 area_gateip() const;
  inline void set_area_gateip(::google::protobuf::uint32 value);
  
  // optional bytes time = 5;
  inline bool has_time() const;
  inline void clear_time();
  inline const ::std::string& time() const;
  inline void set_time(const ::std::string& value);
  inline void set_time(const char* value);
  inline ::std::string* mutable_time();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::std::string* area_name_;
  static const ::std::string _default_area_name_;
  ::google::protobuf::uint32 area_type_;
  ::std::string* area_gatemac_;
  static const ::std::string _default_area_gatemac_;
  ::google::protobuf::uint32 area_gateip_;
  ::std::string* time_;
  static const ::std::string _default_time_;
  
  static const LOG_AREA_AREA default_instance_;
  static const int _offsets_[5];
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LOG_AREA : public ::google::protobuf::Message {
 public:
  LOG_AREA();
  virtual ~LOG_AREA();
  
  LOG_AREA(const LOG_AREA& from);
  
  inline LOG_AREA& operator=(const LOG_AREA& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LOG_AREA& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LOG_AREA* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  typedef LOG_AREA_AREA AREA;
  
  // accessors -------------------------------------------------------
  
  // optional .netmon.LOG_AREA.AREA new_area = 1;
  inline bool has_new_area() const;
  inline void clear_new_area();
  inline const ::netmon::LOG_AREA_AREA& new_area() const;
  inline ::netmon::LOG_AREA_AREA* mutable_new_area();
  
  // optional .netmon.LOG_AREA.AREA old_area = 2;
  inline bool has_old_area() const;
  inline void clear_old_area();
  inline const ::netmon::LOG_AREA_AREA& old_area() const;
  inline ::netmon::LOG_AREA_AREA* mutable_old_area();
  
  // optional uint32 area_opt = 3;
  inline bool has_area_opt() const;
  inline void clear_area_opt();
  inline ::google::protobuf::uint32 area_opt() const;
  inline void set_area_opt(::google::protobuf::uint32 value);
  
  // optional int64 time = 4;
  inline bool has_time() const;
  inline void clear_time();
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::netmon::LOG_AREA_AREA* new_area_;
  ::netmon::LOG_AREA_AREA* old_area_;
  ::google::protobuf::uint32 area_opt_;
  ::google::protobuf::int64 time_;
  
  static const LOG_AREA default_instance_;
  static const int _offsets_[4];
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LOG_USER_SETTING : public ::google::protobuf::Message {
 public:
  LOG_USER_SETTING();
  virtual ~LOG_USER_SETTING();
  
  LOG_USER_SETTING(const LOG_USER_SETTING& from);
  
  inline LOG_USER_SETTING& operator=(const LOG_USER_SETTING& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LOG_USER_SETTING& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LOG_USER_SETTING* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);
  
  // optional uint32 opt = 2;
  inline bool has_opt() const;
  inline void clear_opt();
  inline ::google::protobuf::uint32 opt() const;
  inline void set_opt(::google::protobuf::uint32 value);
  
  // optional int64 time = 3;
  inline bool has_time() const;
  inline void clear_time();
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 opt_;
  ::google::protobuf::int64 time_;
  
  static const LOG_USER_SETTING default_instance_;
  static const int _offsets_[3];
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LOG_DEBUG : public ::google::protobuf::Message {
 public:
  LOG_DEBUG();
  virtual ~LOG_DEBUG();
  
  LOG_DEBUG(const LOG_DEBUG& from);
  
  inline LOG_DEBUG& operator=(const LOG_DEBUG& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LOG_DEBUG& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LOG_DEBUG* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional bytes bug_module = 2;
  inline bool has_bug_module() const;
  inline void clear_bug_module();
  inline const ::std::string& bug_module() const;
  inline void set_bug_module(const ::std::string& value);
  inline void set_bug_module(const char* value);
  inline ::std::string* mutable_bug_module();
  
  // optional uint32 bug_type = 3;
  inline bool has_bug_type() const;
  inline void clear_bug_type();
  inline ::google::protobuf::uint32 bug_type() const;
  inline void set_bug_type(::google::protobuf::uint32 value);
  
  // optional uint32 bug_level = 4;
  inline bool has_bug_level() const;
  inline void clear_bug_level();
  inline ::google::protobuf::uint32 bug_level() const;
  inline void set_bug_level(::google::protobuf::uint32 value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int64 time_;
  ::std::string* bug_module_;
  static const ::std::string _default_bug_module_;
  ::google::protobuf::uint32 bug_type_;
  ::google::protobuf::uint32 bug_level_;
  
  static const LOG_DEBUG default_instance_;
  static const int _offsets_[4];
  
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LOG_UPDATE : public ::google::protobuf::Message {
 public:
  LOG_UPDATE();
  virtual ~LOG_UPDATE();
  
  LOG_UPDATE(const LOG_UPDATE& from);
  
  inline LOG_UPDATE& operator=(const LOG_UPDATE& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LOG_UPDATE& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LOG_UPDATE* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  inline ::google::protobuf::int64 time() const;
  inline void set_time(::google::protobuf::int64 value);
  
  // optional bytes update_file = 2;
  inline bool has_update_file() const;
  inline void clear_update_file();
  inline const ::std::string& update_file() const;
  inline void set_update_file(const ::std::string& value);
  inline void set_update_file(const char* value);
  inline ::std::string* mutable_update_file();
  
  // optional uint32 file_type = 3;
  inline bool has_file_type() const;
  inline void clear_file_type();
  inline ::google::protobuf::uint32 file_type() const;
  inline void set_file_type(::google::protobuf::uint32 value);
  
  // optional uint32 breboot = 4;
  inline bool has_breboot() const;
  inline void clear_breboot();
  inline ::google::protobuf::uint32 breboot() const;
  inline void set_breboot(::google::protobuf::uint32 value);
  
  // optional bool bsuccess = 5;
  inline bool has_bsuccess() const;
  inline void clear_bsuccess();
  inline bool bsuccess() const;
  inline void set_bsuccess(bool value);
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::int64 time_;
  ::std::string* update_file_;
  static const ::std::string _default_update_file_;
  ::google::protobuf::uint32 file_type_;
  ::google::protobuf::uint32 breboot_;
  bool bsuccess_;
  
  static const LOG_UPDATE default_instance_;
  static const int _offsets_[5];
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// -------------------------------------------------------------------

class LOG_SHEID : public ::google::protobuf::Message {
 public:
  LOG_SHEID();
  virtual ~LOG_SHEID();
  
  LOG_SHEID(const LOG_SHEID& from);
  
  inline LOG_SHEID& operator=(const LOG_SHEID& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline static const LOG_SHEID& default_instance() {
    return default_instance_;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _reflection_.unknown_fields();
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _reflection_.mutable_unknown_fields();
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  
  // implements Message ----------------------------------------------
  
  LOG_SHEID* New() const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SetCachedSize(int size) const { _cached_size_ = size; }
  public:
  
  const ::google::protobuf::Descriptor* GetDescriptor() const;
  const ::google::protobuf::Message::Reflection* GetReflection() const;
  ::google::protobuf::Message::Reflection* GetReflection();
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional uint64 time = 1;
  inline bool has_time() const;
  inline void clear_time();
  inline ::google::protobuf::uint64 time() const;
  inline void set_time(::google::protobuf::uint64 value);
  
  // optional int32 block_pc_ip = 2;
  inline bool has_block_pc_ip() const;
  inline void clear_block_pc_ip();
  inline ::google::protobuf::int32 block_pc_ip() const;
  inline void set_block_pc_ip(::google::protobuf::int32 value);
  
  // optional uint32 attack_times = 3;
  inline bool has_attack_times() const;
  inline void clear_attack_times();
  inline ::google::protobuf::uint32 attack_times() const;
  inline void set_attack_times(::google::protobuf::uint32 value);
  
  // optional uint32 attack_type = 4;
  inline bool has_attack_type() const;
  inline void clear_attack_type();
  inline ::google::protobuf::uint32 attack_type() const;
  inline void set_attack_type(::google::protobuf::uint32 value);
  
  // optional bytes reason_id = 5;
  inline bool has_reason_id() const;
  inline void clear_reason_id();
  inline const ::std::string& reason_id() const;
  inline void set_reason_id(const ::std::string& value);
  inline void set_reason_id(const char* value);
  inline ::std::string* mutable_reason_id();
  
 private:
  ::google::protobuf::internal::GeneratedMessageReflection _reflection_;
  mutable int _cached_size_;
  
  ::google::protobuf::uint64 time_;
  ::google::protobuf::int32 block_pc_ip_;
  ::google::protobuf::uint32 attack_times_;
  ::google::protobuf::uint32 attack_type_;
  ::std::string* reason_id_;
  static const ::std::string _default_reason_id_;
  
  static const LOG_SHEID default_instance_;
  static const int _offsets_[5];
  
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
};
// ===================================================================


// ===================================================================


// ===================================================================

// KNetMonLogHeader

// required int32 m_eLogType = 1;
inline bool KNetMonLogHeader::has_m_elogtype() const {
  return _has_bit(0);
}
inline void KNetMonLogHeader::clear_m_elogtype() {
  m_elogtype_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 KNetMonLogHeader::m_elogtype() const {
  return m_elogtype_;
}
inline void KNetMonLogHeader::set_m_elogtype(::google::protobuf::int32 value) {
  _set_bit(0);
  m_elogtype_ = value;
}

// required uint64 m_nID = 2;
inline bool KNetMonLogHeader::has_m_nid() const {
  return _has_bit(1);
}
inline void KNetMonLogHeader::clear_m_nid() {
  m_nid_ = GOOGLE_ULONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::uint64 KNetMonLogHeader::m_nid() const {
  return m_nid_;
}
inline void KNetMonLogHeader::set_m_nid(::google::protobuf::uint64 value) {
  _set_bit(1);
  m_nid_ = value;
}

// -------------------------------------------------------------------

// IPLOG_EXTRADATA_tagTCP_DATA

// optional int32 localPort = 1;
inline bool IPLOG_EXTRADATA_tagTCP_DATA::has_localport() const {
  return _has_bit(0);
}
inline void IPLOG_EXTRADATA_tagTCP_DATA::clear_localport() {
  localport_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 IPLOG_EXTRADATA_tagTCP_DATA::localport() const {
  return localport_;
}
inline void IPLOG_EXTRADATA_tagTCP_DATA::set_localport(::google::protobuf::int32 value) {
  _set_bit(0);
  localport_ = value;
}

// optional int32 remotePort = 2;
inline bool IPLOG_EXTRADATA_tagTCP_DATA::has_remoteport() const {
  return _has_bit(1);
}
inline void IPLOG_EXTRADATA_tagTCP_DATA::clear_remoteport() {
  remoteport_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 IPLOG_EXTRADATA_tagTCP_DATA::remoteport() const {
  return remoteport_;
}
inline void IPLOG_EXTRADATA_tagTCP_DATA::set_remoteport(::google::protobuf::int32 value) {
  _set_bit(1);
  remoteport_ = value;
}

// optional int32 byTcpFlags = 3;
inline bool IPLOG_EXTRADATA_tagTCP_DATA::has_bytcpflags() const {
  return _has_bit(2);
}
inline void IPLOG_EXTRADATA_tagTCP_DATA::clear_bytcpflags() {
  bytcpflags_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 IPLOG_EXTRADATA_tagTCP_DATA::bytcpflags() const {
  return bytcpflags_;
}
inline void IPLOG_EXTRADATA_tagTCP_DATA::set_bytcpflags(::google::protobuf::int32 value) {
  _set_bit(2);
  bytcpflags_ = value;
}

// -------------------------------------------------------------------

// IPLOG_EXTRADATA_tagUDP_DATA

// optional int32 localPort = 1;
inline bool IPLOG_EXTRADATA_tagUDP_DATA::has_localport() const {
  return _has_bit(0);
}
inline void IPLOG_EXTRADATA_tagUDP_DATA::clear_localport() {
  localport_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 IPLOG_EXTRADATA_tagUDP_DATA::localport() const {
  return localport_;
}
inline void IPLOG_EXTRADATA_tagUDP_DATA::set_localport(::google::protobuf::int32 value) {
  _set_bit(0);
  localport_ = value;
}

// optional int32 remotePort = 2;
inline bool IPLOG_EXTRADATA_tagUDP_DATA::has_remoteport() const {
  return _has_bit(1);
}
inline void IPLOG_EXTRADATA_tagUDP_DATA::clear_remoteport() {
  remoteport_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 IPLOG_EXTRADATA_tagUDP_DATA::remoteport() const {
  return remoteport_;
}
inline void IPLOG_EXTRADATA_tagUDP_DATA::set_remoteport(::google::protobuf::int32 value) {
  _set_bit(1);
  remoteport_ = value;
}

// -------------------------------------------------------------------

// IPLOG_EXTRADATA_tagICMP_DATA

// optional int32 byType = 1;
inline bool IPLOG_EXTRADATA_tagICMP_DATA::has_bytype() const {
  return _has_bit(0);
}
inline void IPLOG_EXTRADATA_tagICMP_DATA::clear_bytype() {
  bytype_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 IPLOG_EXTRADATA_tagICMP_DATA::bytype() const {
  return bytype_;
}
inline void IPLOG_EXTRADATA_tagICMP_DATA::set_bytype(::google::protobuf::int32 value) {
  _set_bit(0);
  bytype_ = value;
}

// optional int32 byCode = 2;
inline bool IPLOG_EXTRADATA_tagICMP_DATA::has_bycode() const {
  return _has_bit(1);
}
inline void IPLOG_EXTRADATA_tagICMP_DATA::clear_bycode() {
  bycode_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 IPLOG_EXTRADATA_tagICMP_DATA::bycode() const {
  return bycode_;
}
inline void IPLOG_EXTRADATA_tagICMP_DATA::set_bycode(::google::protobuf::int32 value) {
  _set_bit(1);
  bycode_ = value;
}

// -------------------------------------------------------------------

// IPLOG_EXTRADATA_tagIGMP_DATA

// optional int32 empty = 1;
inline bool IPLOG_EXTRADATA_tagIGMP_DATA::has_empty() const {
  return _has_bit(0);
}
inline void IPLOG_EXTRADATA_tagIGMP_DATA::clear_empty() {
  empty_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 IPLOG_EXTRADATA_tagIGMP_DATA::empty() const {
  return empty_;
}
inline void IPLOG_EXTRADATA_tagIGMP_DATA::set_empty(::google::protobuf::int32 value) {
  _set_bit(0);
  empty_ = value;
}

// -------------------------------------------------------------------

// IPLOG_EXTRADATA

// optional .netmon.IPLOG_EXTRADATA.tagTCP_DATA TCP_DATA = 1;
inline bool IPLOG_EXTRADATA::has_tcp_data() const {
  return _has_bit(0);
}
inline void IPLOG_EXTRADATA::clear_tcp_data() {
  if (tcp_data_ != NULL) tcp_data_->::netmon::IPLOG_EXTRADATA_tagTCP_DATA::Clear();
  _clear_bit(0);
}
inline const ::netmon::IPLOG_EXTRADATA_tagTCP_DATA& IPLOG_EXTRADATA::tcp_data() const {
  return tcp_data_ != NULL ? *tcp_data_ : *default_instance_.tcp_data_;
}
inline ::netmon::IPLOG_EXTRADATA_tagTCP_DATA* IPLOG_EXTRADATA::mutable_tcp_data() {
  _set_bit(0);
  if (tcp_data_ == NULL) tcp_data_ = new ::netmon::IPLOG_EXTRADATA_tagTCP_DATA;
  return tcp_data_;
}

// optional .netmon.IPLOG_EXTRADATA.tagUDP_DATA UDP_DATA = 2;
inline bool IPLOG_EXTRADATA::has_udp_data() const {
  return _has_bit(1);
}
inline void IPLOG_EXTRADATA::clear_udp_data() {
  if (udp_data_ != NULL) udp_data_->::netmon::IPLOG_EXTRADATA_tagUDP_DATA::Clear();
  _clear_bit(1);
}
inline const ::netmon::IPLOG_EXTRADATA_tagUDP_DATA& IPLOG_EXTRADATA::udp_data() const {
  return udp_data_ != NULL ? *udp_data_ : *default_instance_.udp_data_;
}
inline ::netmon::IPLOG_EXTRADATA_tagUDP_DATA* IPLOG_EXTRADATA::mutable_udp_data() {
  _set_bit(1);
  if (udp_data_ == NULL) udp_data_ = new ::netmon::IPLOG_EXTRADATA_tagUDP_DATA;
  return udp_data_;
}

// optional .netmon.IPLOG_EXTRADATA.tagICMP_DATA ICMP_DATA = 3;
inline bool IPLOG_EXTRADATA::has_icmp_data() const {
  return _has_bit(2);
}
inline void IPLOG_EXTRADATA::clear_icmp_data() {
  if (icmp_data_ != NULL) icmp_data_->::netmon::IPLOG_EXTRADATA_tagICMP_DATA::Clear();
  _clear_bit(2);
}
inline const ::netmon::IPLOG_EXTRADATA_tagICMP_DATA& IPLOG_EXTRADATA::icmp_data() const {
  return icmp_data_ != NULL ? *icmp_data_ : *default_instance_.icmp_data_;
}
inline ::netmon::IPLOG_EXTRADATA_tagICMP_DATA* IPLOG_EXTRADATA::mutable_icmp_data() {
  _set_bit(2);
  if (icmp_data_ == NULL) icmp_data_ = new ::netmon::IPLOG_EXTRADATA_tagICMP_DATA;
  return icmp_data_;
}

// optional .netmon.IPLOG_EXTRADATA.tagIGMP_DATA IGMP_DATA = 4;
inline bool IPLOG_EXTRADATA::has_igmp_data() const {
  return _has_bit(3);
}
inline void IPLOG_EXTRADATA::clear_igmp_data() {
  if (igmp_data_ != NULL) igmp_data_->::netmon::IPLOG_EXTRADATA_tagIGMP_DATA::Clear();
  _clear_bit(3);
}
inline const ::netmon::IPLOG_EXTRADATA_tagIGMP_DATA& IPLOG_EXTRADATA::igmp_data() const {
  return igmp_data_ != NULL ? *igmp_data_ : *default_instance_.igmp_data_;
}
inline ::netmon::IPLOG_EXTRADATA_tagIGMP_DATA* IPLOG_EXTRADATA::mutable_igmp_data() {
  _set_bit(3);
  if (igmp_data_ == NULL) igmp_data_ = new ::netmon::IPLOG_EXTRADATA_tagIGMP_DATA;
  return igmp_data_;
}

// -------------------------------------------------------------------

// KLOG_IP

// optional bytes id = 1;
inline bool KLOG_IP::has_id() const {
  return _has_bit(0);
}
inline void KLOG_IP::clear_id() {
  if (id_ != &_default_id_) {
    id_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& KLOG_IP::id() const {
  return *id_;
}
inline void KLOG_IP::set_id(const ::std::string& value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void KLOG_IP::set_id(const char* value) {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline ::std::string* KLOG_IP::mutable_id() {
  _set_bit(0);
  if (id_ == &_default_id_) {
    id_ = new ::std::string;
  }
  return id_;
}

// optional int64 time = 2;
inline bool KLOG_IP::has_time() const {
  return _has_bit(1);
}
inline void KLOG_IP::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  _clear_bit(1);
}
inline ::google::protobuf::int64 KLOG_IP::time() const {
  return time_;
}
inline void KLOG_IP::set_time(::google::protobuf::int64 value) {
  _set_bit(1);
  time_ = value;
}

// optional uint32 nCount = 3;
inline bool KLOG_IP::has_ncount() const {
  return _has_bit(2);
}
inline void KLOG_IP::clear_ncount() {
  ncount_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 KLOG_IP::ncount() const {
  return ncount_;
}
inline void KLOG_IP::set_ncount(::google::protobuf::uint32 value) {
  _set_bit(2);
  ncount_ = value;
}

// optional int32 byProtocolType = 4;
inline bool KLOG_IP::has_byprotocoltype() const {
  return _has_bit(3);
}
inline void KLOG_IP::clear_byprotocoltype() {
  byprotocoltype_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 KLOG_IP::byprotocoltype() const {
  return byprotocoltype_;
}
inline void KLOG_IP::set_byprotocoltype(::google::protobuf::int32 value) {
  _set_bit(3);
  byprotocoltype_ = value;
}

// optional uint32 LocalAddr = 5;
inline bool KLOG_IP::has_localaddr() const {
  return _has_bit(4);
}
inline void KLOG_IP::clear_localaddr() {
  localaddr_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 KLOG_IP::localaddr() const {
  return localaddr_;
}
inline void KLOG_IP::set_localaddr(::google::protobuf::uint32 value) {
  _set_bit(4);
  localaddr_ = value;
}

// optional uint32 RemoteAddr = 6;
inline bool KLOG_IP::has_remoteaddr() const {
  return _has_bit(5);
}
inline void KLOG_IP::clear_remoteaddr() {
  remoteaddr_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 KLOG_IP::remoteaddr() const {
  return remoteaddr_;
}
inline void KLOG_IP::set_remoteaddr(::google::protobuf::uint32 value) {
  _set_bit(5);
  remoteaddr_ = value;
}

// optional int32 byDirection = 7;
inline bool KLOG_IP::has_bydirection() const {
  return _has_bit(6);
}
inline void KLOG_IP::clear_bydirection() {
  bydirection_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 KLOG_IP::bydirection() const {
  return bydirection_;
}
inline void KLOG_IP::set_bydirection(::google::protobuf::int32 value) {
  _set_bit(6);
  bydirection_ = value;
}

// optional int32 nOperation = 8;
inline bool KLOG_IP::has_noperation() const {
  return _has_bit(7);
}
inline void KLOG_IP::clear_noperation() {
  noperation_ = 0;
  _clear_bit(7);
}
inline ::google::protobuf::int32 KLOG_IP::noperation() const {
  return noperation_;
}
inline void KLOG_IP::set_noperation(::google::protobuf::int32 value) {
  _set_bit(7);
  noperation_ = value;
}

// optional uint32 nAttackType = 9;
inline bool KLOG_IP::has_nattacktype() const {
  return _has_bit(8);
}
inline void KLOG_IP::clear_nattacktype() {
  nattacktype_ = 0u;
  _clear_bit(8);
}
inline ::google::protobuf::uint32 KLOG_IP::nattacktype() const {
  return nattacktype_;
}
inline void KLOG_IP::set_nattacktype(::google::protobuf::uint32 value) {
  _set_bit(8);
  nattacktype_ = value;
}

// optional .netmon.IPLOG_EXTRADATA ExtraInfo = 10;
inline bool KLOG_IP::has_extrainfo() const {
  return _has_bit(9);
}
inline void KLOG_IP::clear_extrainfo() {
  if (extrainfo_ != NULL) extrainfo_->::netmon::IPLOG_EXTRADATA::Clear();
  _clear_bit(9);
}
inline const ::netmon::IPLOG_EXTRADATA& KLOG_IP::extrainfo() const {
  return extrainfo_ != NULL ? *extrainfo_ : *default_instance_.extrainfo_;
}
inline ::netmon::IPLOG_EXTRADATA* KLOG_IP::mutable_extrainfo() {
  _set_bit(9);
  if (extrainfo_ == NULL) extrainfo_ = new ::netmon::IPLOG_EXTRADATA;
  return extrainfo_;
}

// -------------------------------------------------------------------

// LOG_MODULE

// optional bytes userid = 1;
inline bool LOG_MODULE::has_userid() const {
  return _has_bit(0);
}
inline void LOG_MODULE::clear_userid() {
  if (userid_ != &_default_userid_) {
    userid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& LOG_MODULE::userid() const {
  return *userid_;
}
inline void LOG_MODULE::set_userid(const ::std::string& value) {
  _set_bit(0);
  if (userid_ == &_default_userid_) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LOG_MODULE::set_userid(const char* value) {
  _set_bit(0);
  if (userid_ == &_default_userid_) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline ::std::string* LOG_MODULE::mutable_userid() {
  _set_bit(0);
  if (userid_ == &_default_userid_) {
    userid_ = new ::std::string;
  }
  return userid_;
}

// optional bytes modulePath = 2;
inline bool LOG_MODULE::has_modulepath() const {
  return _has_bit(1);
}
inline void LOG_MODULE::clear_modulepath() {
  if (modulepath_ != &_default_modulepath_) {
    modulepath_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LOG_MODULE::modulepath() const {
  return *modulepath_;
}
inline void LOG_MODULE::set_modulepath(const ::std::string& value) {
  _set_bit(1);
  if (modulepath_ == &_default_modulepath_) {
    modulepath_ = new ::std::string;
  }
  modulepath_->assign(value);
}
inline void LOG_MODULE::set_modulepath(const char* value) {
  _set_bit(1);
  if (modulepath_ == &_default_modulepath_) {
    modulepath_ = new ::std::string;
  }
  modulepath_->assign(value);
}
inline ::std::string* LOG_MODULE::mutable_modulepath() {
  _set_bit(1);
  if (modulepath_ == &_default_modulepath_) {
    modulepath_ = new ::std::string;
  }
  return modulepath_;
}

// optional uint32 trustModle = 3;
inline bool LOG_MODULE::has_trustmodle() const {
  return _has_bit(2);
}
inline void LOG_MODULE::clear_trustmodle() {
  trustmodle_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 LOG_MODULE::trustmodle() const {
  return trustmodle_;
}
inline void LOG_MODULE::set_trustmodle(::google::protobuf::uint32 value) {
  _set_bit(2);
  trustmodle_ = value;
}

// optional uint32 userModle = 4;
inline bool LOG_MODULE::has_usermodle() const {
  return _has_bit(3);
}
inline void LOG_MODULE::clear_usermodle() {
  usermodle_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 LOG_MODULE::usermodle() const {
  return usermodle_;
}
inline void LOG_MODULE::set_usermodle(::google::protobuf::uint32 value) {
  _set_bit(3);
  usermodle_ = value;
}

// optional uint32 popRes = 5;
inline bool LOG_MODULE::has_popres() const {
  return _has_bit(4);
}
inline void LOG_MODULE::clear_popres() {
  popres_ = 0u;
  _clear_bit(4);
}
inline ::google::protobuf::uint32 LOG_MODULE::popres() const {
  return popres_;
}
inline void LOG_MODULE::set_popres(::google::protobuf::uint32 value) {
  _set_bit(4);
  popres_ = value;
}

// -------------------------------------------------------------------

// LOG_APP

// optional int32 eFlag = 1;
inline bool LOG_APP::has_eflag() const {
  return _has_bit(0);
}
inline void LOG_APP::clear_eflag() {
  eflag_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 LOG_APP::eflag() const {
  return eflag_;
}
inline void LOG_APP::set_eflag(::google::protobuf::int32 value) {
  _set_bit(0);
  eflag_ = value;
}

// optional uint32 dwRemoteAddress = 2;
inline bool LOG_APP::has_dwremoteaddress() const {
  return _has_bit(1);
}
inline void LOG_APP::clear_dwremoteaddress() {
  dwremoteaddress_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 LOG_APP::dwremoteaddress() const {
  return dwremoteaddress_;
}
inline void LOG_APP::set_dwremoteaddress(::google::protobuf::uint32 value) {
  _set_bit(1);
  dwremoteaddress_ = value;
}

// optional uint32 dwLocalAddress = 3;
inline bool LOG_APP::has_dwlocaladdress() const {
  return _has_bit(2);
}
inline void LOG_APP::clear_dwlocaladdress() {
  dwlocaladdress_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 LOG_APP::dwlocaladdress() const {
  return dwlocaladdress_;
}
inline void LOG_APP::set_dwlocaladdress(::google::protobuf::uint32 value) {
  _set_bit(2);
  dwlocaladdress_ = value;
}

// optional int32 wRemotePort = 4;
inline bool LOG_APP::has_wremoteport() const {
  return _has_bit(3);
}
inline void LOG_APP::clear_wremoteport() {
  wremoteport_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 LOG_APP::wremoteport() const {
  return wremoteport_;
}
inline void LOG_APP::set_wremoteport(::google::protobuf::int32 value) {
  _set_bit(3);
  wremoteport_ = value;
}

// optional int32 wLocalPort = 5;
inline bool LOG_APP::has_wlocalport() const {
  return _has_bit(4);
}
inline void LOG_APP::clear_wlocalport() {
  wlocalport_ = 0;
  _clear_bit(4);
}
inline ::google::protobuf::int32 LOG_APP::wlocalport() const {
  return wlocalport_;
}
inline void LOG_APP::set_wlocalport(::google::protobuf::int32 value) {
  _set_bit(4);
  wlocalport_ = value;
}

// optional int32 nRequestType = 6;
inline bool LOG_APP::has_nrequesttype() const {
  return _has_bit(5);
}
inline void LOG_APP::clear_nrequesttype() {
  nrequesttype_ = 0;
  _clear_bit(5);
}
inline ::google::protobuf::int32 LOG_APP::nrequesttype() const {
  return nrequesttype_;
}
inline void LOG_APP::set_nrequesttype(::google::protobuf::int32 value) {
  _set_bit(5);
  nrequesttype_ = value;
}

// optional int32 nRequestProtocol = 7;
inline bool LOG_APP::has_nrequestprotocol() const {
  return _has_bit(6);
}
inline void LOG_APP::clear_nrequestprotocol() {
  nrequestprotocol_ = 0;
  _clear_bit(6);
}
inline ::google::protobuf::int32 LOG_APP::nrequestprotocol() const {
  return nrequestprotocol_;
}
inline void LOG_APP::set_nrequestprotocol(::google::protobuf::int32 value) {
  _set_bit(6);
  nrequestprotocol_ = value;
}

// optional int64 time = 8;
inline bool LOG_APP::has_time() const {
  return _has_bit(7);
}
inline void LOG_APP::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  _clear_bit(7);
}
inline ::google::protobuf::int64 LOG_APP::time() const {
  return time_;
}
inline void LOG_APP::set_time(::google::protobuf::int64 value) {
  _set_bit(7);
  time_ = value;
}

// optional int32 nBehavior = 9;
inline bool LOG_APP::has_nbehavior() const {
  return _has_bit(8);
}
inline void LOG_APP::clear_nbehavior() {
  nbehavior_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 LOG_APP::nbehavior() const {
  return nbehavior_;
}
inline void LOG_APP::set_nbehavior(::google::protobuf::int32 value) {
  _set_bit(8);
  nbehavior_ = value;
}

// optional .netmon.LOG_MODULE exeModule = 10;
inline bool LOG_APP::has_exemodule() const {
  return _has_bit(9);
}
inline void LOG_APP::clear_exemodule() {
  if (exemodule_ != NULL) exemodule_->::netmon::LOG_MODULE::Clear();
  _clear_bit(9);
}
inline const ::netmon::LOG_MODULE& LOG_APP::exemodule() const {
  return exemodule_ != NULL ? *exemodule_ : *default_instance_.exemodule_;
}
inline ::netmon::LOG_MODULE* LOG_APP::mutable_exemodule() {
  _set_bit(9);
  if (exemodule_ == NULL) exemodule_ = new ::netmon::LOG_MODULE;
  return exemodule_;
}

// repeated .netmon.LOG_MODULE dllModules = 11;
inline int LOG_APP::dllmodules_size() const {
  return dllmodules_.size();
}
inline void LOG_APP::clear_dllmodules() {
  dllmodules_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::netmon::LOG_MODULE >&
LOG_APP::dllmodules() const {
  return dllmodules_;
}
inline ::google::protobuf::RepeatedPtrField< ::netmon::LOG_MODULE >*
LOG_APP::mutable_dllmodules() {
  return &dllmodules_;
}
inline const ::netmon::LOG_MODULE& LOG_APP::dllmodules(int index) const {
  return dllmodules_.Get(index);
}
inline ::netmon::LOG_MODULE* LOG_APP::mutable_dllmodules(int index) {
  return dllmodules_.Mutable(index);
}
inline ::netmon::LOG_MODULE* LOG_APP::add_dllmodules() {
  return dllmodules_.Add();
}

// optional bytes lanpath = 12;
inline bool LOG_APP::has_lanpath() const {
  return _has_bit(11);
}
inline void LOG_APP::clear_lanpath() {
  if (lanpath_ != &_default_lanpath_) {
    lanpath_->clear();
  }
  _clear_bit(11);
}
inline const ::std::string& LOG_APP::lanpath() const {
  return *lanpath_;
}
inline void LOG_APP::set_lanpath(const ::std::string& value) {
  _set_bit(11);
  if (lanpath_ == &_default_lanpath_) {
    lanpath_ = new ::std::string;
  }
  lanpath_->assign(value);
}
inline void LOG_APP::set_lanpath(const char* value) {
  _set_bit(11);
  if (lanpath_ == &_default_lanpath_) {
    lanpath_ = new ::std::string;
  }
  lanpath_->assign(value);
}
inline ::std::string* LOG_APP::mutable_lanpath() {
  _set_bit(11);
  if (lanpath_ == &_default_lanpath_) {
    lanpath_ = new ::std::string;
  }
  return lanpath_;
}

// -------------------------------------------------------------------

// IP_RANGE

// optional int32 addr_start = 1;
inline bool IP_RANGE::has_addr_start() const {
  return _has_bit(0);
}
inline void IP_RANGE::clear_addr_start() {
  addr_start_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 IP_RANGE::addr_start() const {
  return addr_start_;
}
inline void IP_RANGE::set_addr_start(::google::protobuf::int32 value) {
  _set_bit(0);
  addr_start_ = value;
}

// optional int32 addr_end = 2;
inline bool IP_RANGE::has_addr_end() const {
  return _has_bit(1);
}
inline void IP_RANGE::clear_addr_end() {
  addr_end_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 IP_RANGE::addr_end() const {
  return addr_end_;
}
inline void IP_RANGE::set_addr_end(::google::protobuf::int32 value) {
  _set_bit(1);
  addr_end_ = value;
}

// -------------------------------------------------------------------

// PORT_RANGE

// optional int32 port_start = 1;
inline bool PORT_RANGE::has_port_start() const {
  return _has_bit(0);
}
inline void PORT_RANGE::clear_port_start() {
  port_start_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 PORT_RANGE::port_start() const {
  return port_start_;
}
inline void PORT_RANGE::set_port_start(::google::protobuf::int32 value) {
  _set_bit(0);
  port_start_ = value;
}

// optional int32 port_end = 2;
inline bool PORT_RANGE::has_port_end() const {
  return _has_bit(1);
}
inline void PORT_RANGE::clear_port_end() {
  port_end_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 PORT_RANGE::port_end() const {
  return port_end_;
}
inline void PORT_RANGE::set_port_end(::google::protobuf::int32 value) {
  _set_bit(1);
  port_end_ = value;
}

// -------------------------------------------------------------------

// FILTER_IP_ADDR

// optional int32 addrmode = 1;
inline bool FILTER_IP_ADDR::has_addrmode() const {
  return _has_bit(0);
}
inline void FILTER_IP_ADDR::clear_addrmode() {
  addrmode_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FILTER_IP_ADDR::addrmode() const {
  return addrmode_;
}
inline void FILTER_IP_ADDR::set_addrmode(::google::protobuf::int32 value) {
  _set_bit(0);
  addrmode_ = value;
}

// optional int32 ipaddr = 2;
inline bool FILTER_IP_ADDR::has_ipaddr() const {
  return _has_bit(1);
}
inline void FILTER_IP_ADDR::clear_ipaddr() {
  ipaddr_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FILTER_IP_ADDR::ipaddr() const {
  return ipaddr_;
}
inline void FILTER_IP_ADDR::set_ipaddr(::google::protobuf::int32 value) {
  _set_bit(1);
  ipaddr_ = value;
}

// optional .netmon.PORT_RANGE addrrange = 3;
inline bool FILTER_IP_ADDR::has_addrrange() const {
  return _has_bit(2);
}
inline void FILTER_IP_ADDR::clear_addrrange() {
  if (addrrange_ != NULL) addrrange_->::netmon::PORT_RANGE::Clear();
  _clear_bit(2);
}
inline const ::netmon::PORT_RANGE& FILTER_IP_ADDR::addrrange() const {
  return addrrange_ != NULL ? *addrrange_ : *default_instance_.addrrange_;
}
inline ::netmon::PORT_RANGE* FILTER_IP_ADDR::mutable_addrrange() {
  _set_bit(2);
  if (addrrange_ == NULL) addrrange_ = new ::netmon::PORT_RANGE;
  return addrrange_;
}

// -------------------------------------------------------------------

// FILTER_IP_PORT

// optional int32 addrmode = 1;
inline bool FILTER_IP_PORT::has_addrmode() const {
  return _has_bit(0);
}
inline void FILTER_IP_PORT::clear_addrmode() {
  addrmode_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FILTER_IP_PORT::addrmode() const {
  return addrmode_;
}
inline void FILTER_IP_PORT::set_addrmode(::google::protobuf::int32 value) {
  _set_bit(0);
  addrmode_ = value;
}

// optional int32 port = 2;
inline bool FILTER_IP_PORT::has_port() const {
  return _has_bit(1);
}
inline void FILTER_IP_PORT::clear_port() {
  port_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FILTER_IP_PORT::port() const {
  return port_;
}
inline void FILTER_IP_PORT::set_port(::google::protobuf::int32 value) {
  _set_bit(1);
  port_ = value;
}

// optional .netmon.PORT_RANGE portrange = 3;
inline bool FILTER_IP_PORT::has_portrange() const {
  return _has_bit(2);
}
inline void FILTER_IP_PORT::clear_portrange() {
  if (portrange_ != NULL) portrange_->::netmon::PORT_RANGE::Clear();
  _clear_bit(2);
}
inline const ::netmon::PORT_RANGE& FILTER_IP_PORT::portrange() const {
  return portrange_ != NULL ? *portrange_ : *default_instance_.portrange_;
}
inline ::netmon::PORT_RANGE* FILTER_IP_PORT::mutable_portrange() {
  _set_bit(2);
  if (portrange_ == NULL) portrange_ = new ::netmon::PORT_RANGE;
  return portrange_;
}

// -------------------------------------------------------------------

// LOG_APP_RULE

// optional bytes userid = 1;
inline bool LOG_APP_RULE::has_userid() const {
  return _has_bit(0);
}
inline void LOG_APP_RULE::clear_userid() {
  if (userid_ != &_default_userid_) {
    userid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& LOG_APP_RULE::userid() const {
  return *userid_;
}
inline void LOG_APP_RULE::set_userid(const ::std::string& value) {
  _set_bit(0);
  if (userid_ == &_default_userid_) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LOG_APP_RULE::set_userid(const char* value) {
  _set_bit(0);
  if (userid_ == &_default_userid_) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline ::std::string* LOG_APP_RULE::mutable_userid() {
  _set_bit(0);
  if (userid_ == &_default_userid_) {
    userid_ = new ::std::string;
  }
  return userid_;
}

// optional bytes ruleid = 2;
inline bool LOG_APP_RULE::has_ruleid() const {
  return _has_bit(1);
}
inline void LOG_APP_RULE::clear_ruleid() {
  if (ruleid_ != &_default_ruleid_) {
    ruleid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LOG_APP_RULE::ruleid() const {
  return *ruleid_;
}
inline void LOG_APP_RULE::set_ruleid(const ::std::string& value) {
  _set_bit(1);
  if (ruleid_ == &_default_ruleid_) {
    ruleid_ = new ::std::string;
  }
  ruleid_->assign(value);
}
inline void LOG_APP_RULE::set_ruleid(const char* value) {
  _set_bit(1);
  if (ruleid_ == &_default_ruleid_) {
    ruleid_ = new ::std::string;
  }
  ruleid_->assign(value);
}
inline ::std::string* LOG_APP_RULE::mutable_ruleid() {
  _set_bit(1);
  if (ruleid_ == &_default_ruleid_) {
    ruleid_ = new ::std::string;
  }
  return ruleid_;
}

// optional bytes modulepath = 3;
inline bool LOG_APP_RULE::has_modulepath() const {
  return _has_bit(2);
}
inline void LOG_APP_RULE::clear_modulepath() {
  if (modulepath_ != &_default_modulepath_) {
    modulepath_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& LOG_APP_RULE::modulepath() const {
  return *modulepath_;
}
inline void LOG_APP_RULE::set_modulepath(const ::std::string& value) {
  _set_bit(2);
  if (modulepath_ == &_default_modulepath_) {
    modulepath_ = new ::std::string;
  }
  modulepath_->assign(value);
}
inline void LOG_APP_RULE::set_modulepath(const char* value) {
  _set_bit(2);
  if (modulepath_ == &_default_modulepath_) {
    modulepath_ = new ::std::string;
  }
  modulepath_->assign(value);
}
inline ::std::string* LOG_APP_RULE::mutable_modulepath() {
  _set_bit(2);
  if (modulepath_ == &_default_modulepath_) {
    modulepath_ = new ::std::string;
  }
  return modulepath_;
}

// optional bytes checksum = 4;
inline bool LOG_APP_RULE::has_checksum() const {
  return _has_bit(3);
}
inline void LOG_APP_RULE::clear_checksum() {
  if (checksum_ != &_default_checksum_) {
    checksum_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& LOG_APP_RULE::checksum() const {
  return *checksum_;
}
inline void LOG_APP_RULE::set_checksum(const ::std::string& value) {
  _set_bit(3);
  if (checksum_ == &_default_checksum_) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline void LOG_APP_RULE::set_checksum(const char* value) {
  _set_bit(3);
  if (checksum_ == &_default_checksum_) {
    checksum_ = new ::std::string;
  }
  checksum_->assign(value);
}
inline ::std::string* LOG_APP_RULE::mutable_checksum() {
  _set_bit(3);
  if (checksum_ == &_default_checksum_) {
    checksum_ = new ::std::string;
  }
  return checksum_;
}

// repeated .netmon.FILTER_IP_PORT tcp_remote_denyports = 5;
inline int LOG_APP_RULE::tcp_remote_denyports_size() const {
  return tcp_remote_denyports_.size();
}
inline void LOG_APP_RULE::clear_tcp_remote_denyports() {
  tcp_remote_denyports_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >&
LOG_APP_RULE::tcp_remote_denyports() const {
  return tcp_remote_denyports_;
}
inline ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >*
LOG_APP_RULE::mutable_tcp_remote_denyports() {
  return &tcp_remote_denyports_;
}
inline const ::netmon::FILTER_IP_PORT& LOG_APP_RULE::tcp_remote_denyports(int index) const {
  return tcp_remote_denyports_.Get(index);
}
inline ::netmon::FILTER_IP_PORT* LOG_APP_RULE::mutable_tcp_remote_denyports(int index) {
  return tcp_remote_denyports_.Mutable(index);
}
inline ::netmon::FILTER_IP_PORT* LOG_APP_RULE::add_tcp_remote_denyports() {
  return tcp_remote_denyports_.Add();
}

// repeated .netmon.FILTER_IP_PORT tcp_local_deny_ports = 6;
inline int LOG_APP_RULE::tcp_local_deny_ports_size() const {
  return tcp_local_deny_ports_.size();
}
inline void LOG_APP_RULE::clear_tcp_local_deny_ports() {
  tcp_local_deny_ports_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >&
LOG_APP_RULE::tcp_local_deny_ports() const {
  return tcp_local_deny_ports_;
}
inline ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >*
LOG_APP_RULE::mutable_tcp_local_deny_ports() {
  return &tcp_local_deny_ports_;
}
inline const ::netmon::FILTER_IP_PORT& LOG_APP_RULE::tcp_local_deny_ports(int index) const {
  return tcp_local_deny_ports_.Get(index);
}
inline ::netmon::FILTER_IP_PORT* LOG_APP_RULE::mutable_tcp_local_deny_ports(int index) {
  return tcp_local_deny_ports_.Mutable(index);
}
inline ::netmon::FILTER_IP_PORT* LOG_APP_RULE::add_tcp_local_deny_ports() {
  return tcp_local_deny_ports_.Add();
}

// repeated .netmon.FILTER_IP_PORT udp_remote_denyports = 7;
inline int LOG_APP_RULE::udp_remote_denyports_size() const {
  return udp_remote_denyports_.size();
}
inline void LOG_APP_RULE::clear_udp_remote_denyports() {
  udp_remote_denyports_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >&
LOG_APP_RULE::udp_remote_denyports() const {
  return udp_remote_denyports_;
}
inline ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >*
LOG_APP_RULE::mutable_udp_remote_denyports() {
  return &udp_remote_denyports_;
}
inline const ::netmon::FILTER_IP_PORT& LOG_APP_RULE::udp_remote_denyports(int index) const {
  return udp_remote_denyports_.Get(index);
}
inline ::netmon::FILTER_IP_PORT* LOG_APP_RULE::mutable_udp_remote_denyports(int index) {
  return udp_remote_denyports_.Mutable(index);
}
inline ::netmon::FILTER_IP_PORT* LOG_APP_RULE::add_udp_remote_denyports() {
  return udp_remote_denyports_.Add();
}

// repeated .netmon.FILTER_IP_PORT udp_local_deny_ports = 8;
inline int LOG_APP_RULE::udp_local_deny_ports_size() const {
  return udp_local_deny_ports_.size();
}
inline void LOG_APP_RULE::clear_udp_local_deny_ports() {
  udp_local_deny_ports_.Clear();
}
inline const ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >&
LOG_APP_RULE::udp_local_deny_ports() const {
  return udp_local_deny_ports_;
}
inline ::google::protobuf::RepeatedPtrField< ::netmon::FILTER_IP_PORT >*
LOG_APP_RULE::mutable_udp_local_deny_ports() {
  return &udp_local_deny_ports_;
}
inline const ::netmon::FILTER_IP_PORT& LOG_APP_RULE::udp_local_deny_ports(int index) const {
  return udp_local_deny_ports_.Get(index);
}
inline ::netmon::FILTER_IP_PORT* LOG_APP_RULE::mutable_udp_local_deny_ports(int index) {
  return udp_local_deny_ports_.Mutable(index);
}
inline ::netmon::FILTER_IP_PORT* LOG_APP_RULE::add_udp_local_deny_ports() {
  return udp_local_deny_ports_.Add();
}

// optional int32 trustmode = 9;
inline bool LOG_APP_RULE::has_trustmode() const {
  return _has_bit(8);
}
inline void LOG_APP_RULE::clear_trustmode() {
  trustmode_ = 0;
  _clear_bit(8);
}
inline ::google::protobuf::int32 LOG_APP_RULE::trustmode() const {
  return trustmode_;
}
inline void LOG_APP_RULE::set_trustmode(::google::protobuf::int32 value) {
  _set_bit(8);
  trustmode_ = value;
}

// optional int32 usermode = 10;
inline bool LOG_APP_RULE::has_usermode() const {
  return _has_bit(9);
}
inline void LOG_APP_RULE::clear_usermode() {
  usermode_ = 0;
  _clear_bit(9);
}
inline ::google::protobuf::int32 LOG_APP_RULE::usermode() const {
  return usermode_;
}
inline void LOG_APP_RULE::set_usermode(::google::protobuf::int32 value) {
  _set_bit(9);
  usermode_ = value;
}

// optional int32 eFlag = 11;
inline bool LOG_APP_RULE::has_eflag() const {
  return _has_bit(10);
}
inline void LOG_APP_RULE::clear_eflag() {
  eflag_ = 0;
  _clear_bit(10);
}
inline ::google::protobuf::int32 LOG_APP_RULE::eflag() const {
  return eflag_;
}
inline void LOG_APP_RULE::set_eflag(::google::protobuf::int32 value) {
  _set_bit(10);
  eflag_ = value;
}

// optional int64 time = 12;
inline bool LOG_APP_RULE::has_time() const {
  return _has_bit(11);
}
inline void LOG_APP_RULE::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  _clear_bit(11);
}
inline ::google::protobuf::int64 LOG_APP_RULE::time() const {
  return time_;
}
inline void LOG_APP_RULE::set_time(::google::protobuf::int64 value) {
  _set_bit(11);
  time_ = value;
}

// optional int32 bDll = 13;
inline bool LOG_APP_RULE::has_bdll() const {
  return _has_bit(12);
}
inline void LOG_APP_RULE::clear_bdll() {
  bdll_ = 0;
  _clear_bit(12);
}
inline ::google::protobuf::int32 LOG_APP_RULE::bdll() const {
  return bdll_;
}
inline void LOG_APP_RULE::set_bdll(::google::protobuf::int32 value) {
  _set_bit(12);
  bdll_ = value;
}

// -------------------------------------------------------------------

// FILTERINFO_EXTRADATA_tagTCP_DATA

// optional .netmon.FILTER_IP_PORT localPort = 1;
inline bool FILTERINFO_EXTRADATA_tagTCP_DATA::has_localport() const {
  return _has_bit(0);
}
inline void FILTERINFO_EXTRADATA_tagTCP_DATA::clear_localport() {
  if (localport_ != NULL) localport_->::netmon::FILTER_IP_PORT::Clear();
  _clear_bit(0);
}
inline const ::netmon::FILTER_IP_PORT& FILTERINFO_EXTRADATA_tagTCP_DATA::localport() const {
  return localport_ != NULL ? *localport_ : *default_instance_.localport_;
}
inline ::netmon::FILTER_IP_PORT* FILTERINFO_EXTRADATA_tagTCP_DATA::mutable_localport() {
  _set_bit(0);
  if (localport_ == NULL) localport_ = new ::netmon::FILTER_IP_PORT;
  return localport_;
}

// optional .netmon.FILTER_IP_PORT remotePort = 2;
inline bool FILTERINFO_EXTRADATA_tagTCP_DATA::has_remoteport() const {
  return _has_bit(1);
}
inline void FILTERINFO_EXTRADATA_tagTCP_DATA::clear_remoteport() {
  if (remoteport_ != NULL) remoteport_->::netmon::FILTER_IP_PORT::Clear();
  _clear_bit(1);
}
inline const ::netmon::FILTER_IP_PORT& FILTERINFO_EXTRADATA_tagTCP_DATA::remoteport() const {
  return remoteport_ != NULL ? *remoteport_ : *default_instance_.remoteport_;
}
inline ::netmon::FILTER_IP_PORT* FILTERINFO_EXTRADATA_tagTCP_DATA::mutable_remoteport() {
  _set_bit(1);
  if (remoteport_ == NULL) remoteport_ = new ::netmon::FILTER_IP_PORT;
  return remoteport_;
}

// optional int32 byTcpFlags = 3;
inline bool FILTERINFO_EXTRADATA_tagTCP_DATA::has_bytcpflags() const {
  return _has_bit(2);
}
inline void FILTERINFO_EXTRADATA_tagTCP_DATA::clear_bytcpflags() {
  bytcpflags_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 FILTERINFO_EXTRADATA_tagTCP_DATA::bytcpflags() const {
  return bytcpflags_;
}
inline void FILTERINFO_EXTRADATA_tagTCP_DATA::set_bytcpflags(::google::protobuf::int32 value) {
  _set_bit(2);
  bytcpflags_ = value;
}

// -------------------------------------------------------------------

// FILTERINFO_EXTRADATA_tagUDP_DATA

// optional .netmon.FILTER_IP_PORT localPort = 1;
inline bool FILTERINFO_EXTRADATA_tagUDP_DATA::has_localport() const {
  return _has_bit(0);
}
inline void FILTERINFO_EXTRADATA_tagUDP_DATA::clear_localport() {
  if (localport_ != NULL) localport_->::netmon::FILTER_IP_PORT::Clear();
  _clear_bit(0);
}
inline const ::netmon::FILTER_IP_PORT& FILTERINFO_EXTRADATA_tagUDP_DATA::localport() const {
  return localport_ != NULL ? *localport_ : *default_instance_.localport_;
}
inline ::netmon::FILTER_IP_PORT* FILTERINFO_EXTRADATA_tagUDP_DATA::mutable_localport() {
  _set_bit(0);
  if (localport_ == NULL) localport_ = new ::netmon::FILTER_IP_PORT;
  return localport_;
}

// optional .netmon.FILTER_IP_PORT remotePort = 2;
inline bool FILTERINFO_EXTRADATA_tagUDP_DATA::has_remoteport() const {
  return _has_bit(1);
}
inline void FILTERINFO_EXTRADATA_tagUDP_DATA::clear_remoteport() {
  if (remoteport_ != NULL) remoteport_->::netmon::FILTER_IP_PORT::Clear();
  _clear_bit(1);
}
inline const ::netmon::FILTER_IP_PORT& FILTERINFO_EXTRADATA_tagUDP_DATA::remoteport() const {
  return remoteport_ != NULL ? *remoteport_ : *default_instance_.remoteport_;
}
inline ::netmon::FILTER_IP_PORT* FILTERINFO_EXTRADATA_tagUDP_DATA::mutable_remoteport() {
  _set_bit(1);
  if (remoteport_ == NULL) remoteport_ = new ::netmon::FILTER_IP_PORT;
  return remoteport_;
}

// -------------------------------------------------------------------

// FILTERINFO_EXTRADATA_tagICMP_DATA

// optional int32 byType = 1;
inline bool FILTERINFO_EXTRADATA_tagICMP_DATA::has_bytype() const {
  return _has_bit(0);
}
inline void FILTERINFO_EXTRADATA_tagICMP_DATA::clear_bytype() {
  bytype_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FILTERINFO_EXTRADATA_tagICMP_DATA::bytype() const {
  return bytype_;
}
inline void FILTERINFO_EXTRADATA_tagICMP_DATA::set_bytype(::google::protobuf::int32 value) {
  _set_bit(0);
  bytype_ = value;
}

// optional int32 byCode = 2;
inline bool FILTERINFO_EXTRADATA_tagICMP_DATA::has_bycode() const {
  return _has_bit(1);
}
inline void FILTERINFO_EXTRADATA_tagICMP_DATA::clear_bycode() {
  bycode_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FILTERINFO_EXTRADATA_tagICMP_DATA::bycode() const {
  return bycode_;
}
inline void FILTERINFO_EXTRADATA_tagICMP_DATA::set_bycode(::google::protobuf::int32 value) {
  _set_bit(1);
  bycode_ = value;
}

// -------------------------------------------------------------------

// FILTERINFO_EXTRADATA_tagIGMP_DATA

// optional int32 empty = 1;
inline bool FILTERINFO_EXTRADATA_tagIGMP_DATA::has_empty() const {
  return _has_bit(0);
}
inline void FILTERINFO_EXTRADATA_tagIGMP_DATA::clear_empty() {
  empty_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FILTERINFO_EXTRADATA_tagIGMP_DATA::empty() const {
  return empty_;
}
inline void FILTERINFO_EXTRADATA_tagIGMP_DATA::set_empty(::google::protobuf::int32 value) {
  _set_bit(0);
  empty_ = value;
}

// -------------------------------------------------------------------

// FILTERINFO_EXTRADATA

// optional .netmon.FILTERINFO_EXTRADATA.tagTCP_DATA TCP_DATA = 1;
inline bool FILTERINFO_EXTRADATA::has_tcp_data() const {
  return _has_bit(0);
}
inline void FILTERINFO_EXTRADATA::clear_tcp_data() {
  if (tcp_data_ != NULL) tcp_data_->::netmon::FILTERINFO_EXTRADATA_tagTCP_DATA::Clear();
  _clear_bit(0);
}
inline const ::netmon::FILTERINFO_EXTRADATA_tagTCP_DATA& FILTERINFO_EXTRADATA::tcp_data() const {
  return tcp_data_ != NULL ? *tcp_data_ : *default_instance_.tcp_data_;
}
inline ::netmon::FILTERINFO_EXTRADATA_tagTCP_DATA* FILTERINFO_EXTRADATA::mutable_tcp_data() {
  _set_bit(0);
  if (tcp_data_ == NULL) tcp_data_ = new ::netmon::FILTERINFO_EXTRADATA_tagTCP_DATA;
  return tcp_data_;
}

// optional .netmon.FILTERINFO_EXTRADATA.tagUDP_DATA UDP_DATA = 2;
inline bool FILTERINFO_EXTRADATA::has_udp_data() const {
  return _has_bit(1);
}
inline void FILTERINFO_EXTRADATA::clear_udp_data() {
  if (udp_data_ != NULL) udp_data_->::netmon::FILTERINFO_EXTRADATA_tagUDP_DATA::Clear();
  _clear_bit(1);
}
inline const ::netmon::FILTERINFO_EXTRADATA_tagUDP_DATA& FILTERINFO_EXTRADATA::udp_data() const {
  return udp_data_ != NULL ? *udp_data_ : *default_instance_.udp_data_;
}
inline ::netmon::FILTERINFO_EXTRADATA_tagUDP_DATA* FILTERINFO_EXTRADATA::mutable_udp_data() {
  _set_bit(1);
  if (udp_data_ == NULL) udp_data_ = new ::netmon::FILTERINFO_EXTRADATA_tagUDP_DATA;
  return udp_data_;
}

// optional .netmon.FILTERINFO_EXTRADATA.tagICMP_DATA ICMP_DATA = 3;
inline bool FILTERINFO_EXTRADATA::has_icmp_data() const {
  return _has_bit(2);
}
inline void FILTERINFO_EXTRADATA::clear_icmp_data() {
  if (icmp_data_ != NULL) icmp_data_->::netmon::FILTERINFO_EXTRADATA_tagICMP_DATA::Clear();
  _clear_bit(2);
}
inline const ::netmon::FILTERINFO_EXTRADATA_tagICMP_DATA& FILTERINFO_EXTRADATA::icmp_data() const {
  return icmp_data_ != NULL ? *icmp_data_ : *default_instance_.icmp_data_;
}
inline ::netmon::FILTERINFO_EXTRADATA_tagICMP_DATA* FILTERINFO_EXTRADATA::mutable_icmp_data() {
  _set_bit(2);
  if (icmp_data_ == NULL) icmp_data_ = new ::netmon::FILTERINFO_EXTRADATA_tagICMP_DATA;
  return icmp_data_;
}

// optional .netmon.FILTERINFO_EXTRADATA.tagIGMP_DATA IGMP_DATA = 4;
inline bool FILTERINFO_EXTRADATA::has_igmp_data() const {
  return _has_bit(3);
}
inline void FILTERINFO_EXTRADATA::clear_igmp_data() {
  if (igmp_data_ != NULL) igmp_data_->::netmon::FILTERINFO_EXTRADATA_tagIGMP_DATA::Clear();
  _clear_bit(3);
}
inline const ::netmon::FILTERINFO_EXTRADATA_tagIGMP_DATA& FILTERINFO_EXTRADATA::igmp_data() const {
  return igmp_data_ != NULL ? *igmp_data_ : *default_instance_.igmp_data_;
}
inline ::netmon::FILTERINFO_EXTRADATA_tagIGMP_DATA* FILTERINFO_EXTRADATA::mutable_igmp_data() {
  _set_bit(3);
  if (igmp_data_ == NULL) igmp_data_ = new ::netmon::FILTERINFO_EXTRADATA_tagIGMP_DATA;
  return igmp_data_;
}

// -------------------------------------------------------------------

// FILTER_INFO

// optional int32 protocoltype = 1;
inline bool FILTER_INFO::has_protocoltype() const {
  return _has_bit(0);
}
inline void FILTER_INFO::clear_protocoltype() {
  protocoltype_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 FILTER_INFO::protocoltype() const {
  return protocoltype_;
}
inline void FILTER_INFO::set_protocoltype(::google::protobuf::int32 value) {
  _set_bit(0);
  protocoltype_ = value;
}

// optional int32 direction = 2;
inline bool FILTER_INFO::has_direction() const {
  return _has_bit(1);
}
inline void FILTER_INFO::clear_direction() {
  direction_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 FILTER_INFO::direction() const {
  return direction_;
}
inline void FILTER_INFO::set_direction(::google::protobuf::int32 value) {
  _set_bit(1);
  direction_ = value;
}

// optional int32 operation = 3;
inline bool FILTER_INFO::has_operation() const {
  return _has_bit(2);
}
inline void FILTER_INFO::clear_operation() {
  operation_ = 0;
  _clear_bit(2);
}
inline ::google::protobuf::int32 FILTER_INFO::operation() const {
  return operation_;
}
inline void FILTER_INFO::set_operation(::google::protobuf::int32 value) {
  _set_bit(2);
  operation_ = value;
}

// optional .netmon.FILTER_IP_ADDR localaddr = 4;
inline bool FILTER_INFO::has_localaddr() const {
  return _has_bit(3);
}
inline void FILTER_INFO::clear_localaddr() {
  if (localaddr_ != NULL) localaddr_->::netmon::FILTER_IP_ADDR::Clear();
  _clear_bit(3);
}
inline const ::netmon::FILTER_IP_ADDR& FILTER_INFO::localaddr() const {
  return localaddr_ != NULL ? *localaddr_ : *default_instance_.localaddr_;
}
inline ::netmon::FILTER_IP_ADDR* FILTER_INFO::mutable_localaddr() {
  _set_bit(3);
  if (localaddr_ == NULL) localaddr_ = new ::netmon::FILTER_IP_ADDR;
  return localaddr_;
}

// optional .netmon.FILTER_IP_ADDR remoteaddr = 5;
inline bool FILTER_INFO::has_remoteaddr() const {
  return _has_bit(4);
}
inline void FILTER_INFO::clear_remoteaddr() {
  if (remoteaddr_ != NULL) remoteaddr_->::netmon::FILTER_IP_ADDR::Clear();
  _clear_bit(4);
}
inline const ::netmon::FILTER_IP_ADDR& FILTER_INFO::remoteaddr() const {
  return remoteaddr_ != NULL ? *remoteaddr_ : *default_instance_.remoteaddr_;
}
inline ::netmon::FILTER_IP_ADDR* FILTER_INFO::mutable_remoteaddr() {
  _set_bit(4);
  if (remoteaddr_ == NULL) remoteaddr_ = new ::netmon::FILTER_IP_ADDR;
  return remoteaddr_;
}

// optional .netmon.FILTERINFO_EXTRADATA externdata = 6;
inline bool FILTER_INFO::has_externdata() const {
  return _has_bit(5);
}
inline void FILTER_INFO::clear_externdata() {
  if (externdata_ != NULL) externdata_->::netmon::FILTERINFO_EXTRADATA::Clear();
  _clear_bit(5);
}
inline const ::netmon::FILTERINFO_EXTRADATA& FILTER_INFO::externdata() const {
  return externdata_ != NULL ? *externdata_ : *default_instance_.externdata_;
}
inline ::netmon::FILTERINFO_EXTRADATA* FILTER_INFO::mutable_externdata() {
  _set_bit(5);
  if (externdata_ == NULL) externdata_ = new ::netmon::FILTERINFO_EXTRADATA;
  return externdata_;
}

// -------------------------------------------------------------------

// LOG_IP_RULE

// optional bytes userid = 1;
inline bool LOG_IP_RULE::has_userid() const {
  return _has_bit(0);
}
inline void LOG_IP_RULE::clear_userid() {
  if (userid_ != &_default_userid_) {
    userid_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& LOG_IP_RULE::userid() const {
  return *userid_;
}
inline void LOG_IP_RULE::set_userid(const ::std::string& value) {
  _set_bit(0);
  if (userid_ == &_default_userid_) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline void LOG_IP_RULE::set_userid(const char* value) {
  _set_bit(0);
  if (userid_ == &_default_userid_) {
    userid_ = new ::std::string;
  }
  userid_->assign(value);
}
inline ::std::string* LOG_IP_RULE::mutable_userid() {
  _set_bit(0);
  if (userid_ == &_default_userid_) {
    userid_ = new ::std::string;
  }
  return userid_;
}

// optional bytes ruleid = 2;
inline bool LOG_IP_RULE::has_ruleid() const {
  return _has_bit(1);
}
inline void LOG_IP_RULE::clear_ruleid() {
  if (ruleid_ != &_default_ruleid_) {
    ruleid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LOG_IP_RULE::ruleid() const {
  return *ruleid_;
}
inline void LOG_IP_RULE::set_ruleid(const ::std::string& value) {
  _set_bit(1);
  if (ruleid_ == &_default_ruleid_) {
    ruleid_ = new ::std::string;
  }
  ruleid_->assign(value);
}
inline void LOG_IP_RULE::set_ruleid(const char* value) {
  _set_bit(1);
  if (ruleid_ == &_default_ruleid_) {
    ruleid_ = new ::std::string;
  }
  ruleid_->assign(value);
}
inline ::std::string* LOG_IP_RULE::mutable_ruleid() {
  _set_bit(1);
  if (ruleid_ == &_default_ruleid_) {
    ruleid_ = new ::std::string;
  }
  return ruleid_;
}

// optional bytes name = 3;
inline bool LOG_IP_RULE::has_name() const {
  return _has_bit(2);
}
inline void LOG_IP_RULE::clear_name() {
  if (name_ != &_default_name_) {
    name_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& LOG_IP_RULE::name() const {
  return *name_;
}
inline void LOG_IP_RULE::set_name(const ::std::string& value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LOG_IP_RULE::set_name(const char* value) {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline ::std::string* LOG_IP_RULE::mutable_name() {
  _set_bit(2);
  if (name_ == &_default_name_) {
    name_ = new ::std::string;
  }
  return name_;
}

// optional int32 valid = 4;
inline bool LOG_IP_RULE::has_valid() const {
  return _has_bit(3);
}
inline void LOG_IP_RULE::clear_valid() {
  valid_ = 0;
  _clear_bit(3);
}
inline ::google::protobuf::int32 LOG_IP_RULE::valid() const {
  return valid_;
}
inline void LOG_IP_RULE::set_valid(::google::protobuf::int32 value) {
  _set_bit(3);
  valid_ = value;
}

// optional .netmon.FILTER_INFO filterinfo = 5;
inline bool LOG_IP_RULE::has_filterinfo() const {
  return _has_bit(4);
}
inline void LOG_IP_RULE::clear_filterinfo() {
  if (filterinfo_ != NULL) filterinfo_->::netmon::FILTER_INFO::Clear();
  _clear_bit(4);
}
inline const ::netmon::FILTER_INFO& LOG_IP_RULE::filterinfo() const {
  return filterinfo_ != NULL ? *filterinfo_ : *default_instance_.filterinfo_;
}
inline ::netmon::FILTER_INFO* LOG_IP_RULE::mutable_filterinfo() {
  _set_bit(4);
  if (filterinfo_ == NULL) filterinfo_ = new ::netmon::FILTER_INFO;
  return filterinfo_;
}

// -------------------------------------------------------------------

// LOG_ARP

// optional int32 count = 1;
inline bool LOG_ARP::has_count() const {
  return _has_bit(0);
}
inline void LOG_ARP::clear_count() {
  count_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 LOG_ARP::count() const {
  return count_;
}
inline void LOG_ARP::set_count(::google::protobuf::int32 value) {
  _set_bit(0);
  count_ = value;
}

// optional int32 block_type = 2;
inline bool LOG_ARP::has_block_type() const {
  return _has_bit(1);
}
inline void LOG_ARP::clear_block_type() {
  block_type_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 LOG_ARP::block_type() const {
  return block_type_;
}
inline void LOG_ARP::set_block_type(::google::protobuf::int32 value) {
  _set_bit(1);
  block_type_ = value;
}

// optional bytes eh_destaddr = 3;
inline bool LOG_ARP::has_eh_destaddr() const {
  return _has_bit(2);
}
inline void LOG_ARP::clear_eh_destaddr() {
  if (eh_destaddr_ != &_default_eh_destaddr_) {
    eh_destaddr_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& LOG_ARP::eh_destaddr() const {
  return *eh_destaddr_;
}
inline void LOG_ARP::set_eh_destaddr(const ::std::string& value) {
  _set_bit(2);
  if (eh_destaddr_ == &_default_eh_destaddr_) {
    eh_destaddr_ = new ::std::string;
  }
  eh_destaddr_->assign(value);
}
inline void LOG_ARP::set_eh_destaddr(const char* value) {
  _set_bit(2);
  if (eh_destaddr_ == &_default_eh_destaddr_) {
    eh_destaddr_ = new ::std::string;
  }
  eh_destaddr_->assign(value);
}
inline ::std::string* LOG_ARP::mutable_eh_destaddr() {
  _set_bit(2);
  if (eh_destaddr_ == &_default_eh_destaddr_) {
    eh_destaddr_ = new ::std::string;
  }
  return eh_destaddr_;
}

// optional bytes eh_srcaddr = 4;
inline bool LOG_ARP::has_eh_srcaddr() const {
  return _has_bit(3);
}
inline void LOG_ARP::clear_eh_srcaddr() {
  if (eh_srcaddr_ != &_default_eh_srcaddr_) {
    eh_srcaddr_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& LOG_ARP::eh_srcaddr() const {
  return *eh_srcaddr_;
}
inline void LOG_ARP::set_eh_srcaddr(const ::std::string& value) {
  _set_bit(3);
  if (eh_srcaddr_ == &_default_eh_srcaddr_) {
    eh_srcaddr_ = new ::std::string;
  }
  eh_srcaddr_->assign(value);
}
inline void LOG_ARP::set_eh_srcaddr(const char* value) {
  _set_bit(3);
  if (eh_srcaddr_ == &_default_eh_srcaddr_) {
    eh_srcaddr_ = new ::std::string;
  }
  eh_srcaddr_->assign(value);
}
inline ::std::string* LOG_ARP::mutable_eh_srcaddr() {
  _set_bit(3);
  if (eh_srcaddr_ == &_default_eh_srcaddr_) {
    eh_srcaddr_ = new ::std::string;
  }
  return eh_srcaddr_;
}

// optional bytes arp_sender_haddr = 5;
inline bool LOG_ARP::has_arp_sender_haddr() const {
  return _has_bit(4);
}
inline void LOG_ARP::clear_arp_sender_haddr() {
  if (arp_sender_haddr_ != &_default_arp_sender_haddr_) {
    arp_sender_haddr_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& LOG_ARP::arp_sender_haddr() const {
  return *arp_sender_haddr_;
}
inline void LOG_ARP::set_arp_sender_haddr(const ::std::string& value) {
  _set_bit(4);
  if (arp_sender_haddr_ == &_default_arp_sender_haddr_) {
    arp_sender_haddr_ = new ::std::string;
  }
  arp_sender_haddr_->assign(value);
}
inline void LOG_ARP::set_arp_sender_haddr(const char* value) {
  _set_bit(4);
  if (arp_sender_haddr_ == &_default_arp_sender_haddr_) {
    arp_sender_haddr_ = new ::std::string;
  }
  arp_sender_haddr_->assign(value);
}
inline ::std::string* LOG_ARP::mutable_arp_sender_haddr() {
  _set_bit(4);
  if (arp_sender_haddr_ == &_default_arp_sender_haddr_) {
    arp_sender_haddr_ = new ::std::string;
  }
  return arp_sender_haddr_;
}

// optional uint32 arp_sender_addr = 6;
inline bool LOG_ARP::has_arp_sender_addr() const {
  return _has_bit(5);
}
inline void LOG_ARP::clear_arp_sender_addr() {
  arp_sender_addr_ = 0u;
  _clear_bit(5);
}
inline ::google::protobuf::uint32 LOG_ARP::arp_sender_addr() const {
  return arp_sender_addr_;
}
inline void LOG_ARP::set_arp_sender_addr(::google::protobuf::uint32 value) {
  _set_bit(5);
  arp_sender_addr_ = value;
}

// optional bytes arp_target_haddr = 7;
inline bool LOG_ARP::has_arp_target_haddr() const {
  return _has_bit(6);
}
inline void LOG_ARP::clear_arp_target_haddr() {
  if (arp_target_haddr_ != &_default_arp_target_haddr_) {
    arp_target_haddr_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& LOG_ARP::arp_target_haddr() const {
  return *arp_target_haddr_;
}
inline void LOG_ARP::set_arp_target_haddr(const ::std::string& value) {
  _set_bit(6);
  if (arp_target_haddr_ == &_default_arp_target_haddr_) {
    arp_target_haddr_ = new ::std::string;
  }
  arp_target_haddr_->assign(value);
}
inline void LOG_ARP::set_arp_target_haddr(const char* value) {
  _set_bit(6);
  if (arp_target_haddr_ == &_default_arp_target_haddr_) {
    arp_target_haddr_ = new ::std::string;
  }
  arp_target_haddr_->assign(value);
}
inline ::std::string* LOG_ARP::mutable_arp_target_haddr() {
  _set_bit(6);
  if (arp_target_haddr_ == &_default_arp_target_haddr_) {
    arp_target_haddr_ = new ::std::string;
  }
  return arp_target_haddr_;
}

// optional uint32 arp_target_addr = 8;
inline bool LOG_ARP::has_arp_target_addr() const {
  return _has_bit(7);
}
inline void LOG_ARP::clear_arp_target_addr() {
  arp_target_addr_ = 0u;
  _clear_bit(7);
}
inline ::google::protobuf::uint32 LOG_ARP::arp_target_addr() const {
  return arp_target_addr_;
}
inline void LOG_ARP::set_arp_target_addr(::google::protobuf::uint32 value) {
  _set_bit(7);
  arp_target_addr_ = value;
}

// optional int64 time = 9;
inline bool LOG_ARP::has_time() const {
  return _has_bit(8);
}
inline void LOG_ARP::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  _clear_bit(8);
}
inline ::google::protobuf::int64 LOG_ARP::time() const {
  return time_;
}
inline void LOG_ARP::set_time(::google::protobuf::int64 value) {
  _set_bit(8);
  time_ = value;
}

// -------------------------------------------------------------------

// LOG_AREA_AREA

// optional bytes area_name = 1;
inline bool LOG_AREA_AREA::has_area_name() const {
  return _has_bit(0);
}
inline void LOG_AREA_AREA::clear_area_name() {
  if (area_name_ != &_default_area_name_) {
    area_name_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& LOG_AREA_AREA::area_name() const {
  return *area_name_;
}
inline void LOG_AREA_AREA::set_area_name(const ::std::string& value) {
  _set_bit(0);
  if (area_name_ == &_default_area_name_) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline void LOG_AREA_AREA::set_area_name(const char* value) {
  _set_bit(0);
  if (area_name_ == &_default_area_name_) {
    area_name_ = new ::std::string;
  }
  area_name_->assign(value);
}
inline ::std::string* LOG_AREA_AREA::mutable_area_name() {
  _set_bit(0);
  if (area_name_ == &_default_area_name_) {
    area_name_ = new ::std::string;
  }
  return area_name_;
}

// optional uint32 area_type = 2;
inline bool LOG_AREA_AREA::has_area_type() const {
  return _has_bit(1);
}
inline void LOG_AREA_AREA::clear_area_type() {
  area_type_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 LOG_AREA_AREA::area_type() const {
  return area_type_;
}
inline void LOG_AREA_AREA::set_area_type(::google::protobuf::uint32 value) {
  _set_bit(1);
  area_type_ = value;
}

// optional bytes area_gatemac = 3;
inline bool LOG_AREA_AREA::has_area_gatemac() const {
  return _has_bit(2);
}
inline void LOG_AREA_AREA::clear_area_gatemac() {
  if (area_gatemac_ != &_default_area_gatemac_) {
    area_gatemac_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& LOG_AREA_AREA::area_gatemac() const {
  return *area_gatemac_;
}
inline void LOG_AREA_AREA::set_area_gatemac(const ::std::string& value) {
  _set_bit(2);
  if (area_gatemac_ == &_default_area_gatemac_) {
    area_gatemac_ = new ::std::string;
  }
  area_gatemac_->assign(value);
}
inline void LOG_AREA_AREA::set_area_gatemac(const char* value) {
  _set_bit(2);
  if (area_gatemac_ == &_default_area_gatemac_) {
    area_gatemac_ = new ::std::string;
  }
  area_gatemac_->assign(value);
}
inline ::std::string* LOG_AREA_AREA::mutable_area_gatemac() {
  _set_bit(2);
  if (area_gatemac_ == &_default_area_gatemac_) {
    area_gatemac_ = new ::std::string;
  }
  return area_gatemac_;
}

// optional uint32 area_gateip = 4;
inline bool LOG_AREA_AREA::has_area_gateip() const {
  return _has_bit(3);
}
inline void LOG_AREA_AREA::clear_area_gateip() {
  area_gateip_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 LOG_AREA_AREA::area_gateip() const {
  return area_gateip_;
}
inline void LOG_AREA_AREA::set_area_gateip(::google::protobuf::uint32 value) {
  _set_bit(3);
  area_gateip_ = value;
}

// optional bytes time = 5;
inline bool LOG_AREA_AREA::has_time() const {
  return _has_bit(4);
}
inline void LOG_AREA_AREA::clear_time() {
  if (time_ != &_default_time_) {
    time_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& LOG_AREA_AREA::time() const {
  return *time_;
}
inline void LOG_AREA_AREA::set_time(const ::std::string& value) {
  _set_bit(4);
  if (time_ == &_default_time_) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline void LOG_AREA_AREA::set_time(const char* value) {
  _set_bit(4);
  if (time_ == &_default_time_) {
    time_ = new ::std::string;
  }
  time_->assign(value);
}
inline ::std::string* LOG_AREA_AREA::mutable_time() {
  _set_bit(4);
  if (time_ == &_default_time_) {
    time_ = new ::std::string;
  }
  return time_;
}

// -------------------------------------------------------------------

// LOG_AREA

// optional .netmon.LOG_AREA.AREA new_area = 1;
inline bool LOG_AREA::has_new_area() const {
  return _has_bit(0);
}
inline void LOG_AREA::clear_new_area() {
  if (new_area_ != NULL) new_area_->::netmon::LOG_AREA_AREA::Clear();
  _clear_bit(0);
}
inline const ::netmon::LOG_AREA_AREA& LOG_AREA::new_area() const {
  return new_area_ != NULL ? *new_area_ : *default_instance_.new_area_;
}
inline ::netmon::LOG_AREA_AREA* LOG_AREA::mutable_new_area() {
  _set_bit(0);
  if (new_area_ == NULL) new_area_ = new ::netmon::LOG_AREA_AREA;
  return new_area_;
}

// optional .netmon.LOG_AREA.AREA old_area = 2;
inline bool LOG_AREA::has_old_area() const {
  return _has_bit(1);
}
inline void LOG_AREA::clear_old_area() {
  if (old_area_ != NULL) old_area_->::netmon::LOG_AREA_AREA::Clear();
  _clear_bit(1);
}
inline const ::netmon::LOG_AREA_AREA& LOG_AREA::old_area() const {
  return old_area_ != NULL ? *old_area_ : *default_instance_.old_area_;
}
inline ::netmon::LOG_AREA_AREA* LOG_AREA::mutable_old_area() {
  _set_bit(1);
  if (old_area_ == NULL) old_area_ = new ::netmon::LOG_AREA_AREA;
  return old_area_;
}

// optional uint32 area_opt = 3;
inline bool LOG_AREA::has_area_opt() const {
  return _has_bit(2);
}
inline void LOG_AREA::clear_area_opt() {
  area_opt_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 LOG_AREA::area_opt() const {
  return area_opt_;
}
inline void LOG_AREA::set_area_opt(::google::protobuf::uint32 value) {
  _set_bit(2);
  area_opt_ = value;
}

// optional int64 time = 4;
inline bool LOG_AREA::has_time() const {
  return _has_bit(3);
}
inline void LOG_AREA::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  _clear_bit(3);
}
inline ::google::protobuf::int64 LOG_AREA::time() const {
  return time_;
}
inline void LOG_AREA::set_time(::google::protobuf::int64 value) {
  _set_bit(3);
  time_ = value;
}

// -------------------------------------------------------------------

// LOG_USER_SETTING

// optional uint32 type = 1;
inline bool LOG_USER_SETTING::has_type() const {
  return _has_bit(0);
}
inline void LOG_USER_SETTING::clear_type() {
  type_ = 0u;
  _clear_bit(0);
}
inline ::google::protobuf::uint32 LOG_USER_SETTING::type() const {
  return type_;
}
inline void LOG_USER_SETTING::set_type(::google::protobuf::uint32 value) {
  _set_bit(0);
  type_ = value;
}

// optional uint32 opt = 2;
inline bool LOG_USER_SETTING::has_opt() const {
  return _has_bit(1);
}
inline void LOG_USER_SETTING::clear_opt() {
  opt_ = 0u;
  _clear_bit(1);
}
inline ::google::protobuf::uint32 LOG_USER_SETTING::opt() const {
  return opt_;
}
inline void LOG_USER_SETTING::set_opt(::google::protobuf::uint32 value) {
  _set_bit(1);
  opt_ = value;
}

// optional int64 time = 3;
inline bool LOG_USER_SETTING::has_time() const {
  return _has_bit(2);
}
inline void LOG_USER_SETTING::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  _clear_bit(2);
}
inline ::google::protobuf::int64 LOG_USER_SETTING::time() const {
  return time_;
}
inline void LOG_USER_SETTING::set_time(::google::protobuf::int64 value) {
  _set_bit(2);
  time_ = value;
}

// -------------------------------------------------------------------

// LOG_DEBUG

// optional int64 time = 1;
inline bool LOG_DEBUG::has_time() const {
  return _has_bit(0);
}
inline void LOG_DEBUG::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::int64 LOG_DEBUG::time() const {
  return time_;
}
inline void LOG_DEBUG::set_time(::google::protobuf::int64 value) {
  _set_bit(0);
  time_ = value;
}

// optional bytes bug_module = 2;
inline bool LOG_DEBUG::has_bug_module() const {
  return _has_bit(1);
}
inline void LOG_DEBUG::clear_bug_module() {
  if (bug_module_ != &_default_bug_module_) {
    bug_module_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LOG_DEBUG::bug_module() const {
  return *bug_module_;
}
inline void LOG_DEBUG::set_bug_module(const ::std::string& value) {
  _set_bit(1);
  if (bug_module_ == &_default_bug_module_) {
    bug_module_ = new ::std::string;
  }
  bug_module_->assign(value);
}
inline void LOG_DEBUG::set_bug_module(const char* value) {
  _set_bit(1);
  if (bug_module_ == &_default_bug_module_) {
    bug_module_ = new ::std::string;
  }
  bug_module_->assign(value);
}
inline ::std::string* LOG_DEBUG::mutable_bug_module() {
  _set_bit(1);
  if (bug_module_ == &_default_bug_module_) {
    bug_module_ = new ::std::string;
  }
  return bug_module_;
}

// optional uint32 bug_type = 3;
inline bool LOG_DEBUG::has_bug_type() const {
  return _has_bit(2);
}
inline void LOG_DEBUG::clear_bug_type() {
  bug_type_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 LOG_DEBUG::bug_type() const {
  return bug_type_;
}
inline void LOG_DEBUG::set_bug_type(::google::protobuf::uint32 value) {
  _set_bit(2);
  bug_type_ = value;
}

// optional uint32 bug_level = 4;
inline bool LOG_DEBUG::has_bug_level() const {
  return _has_bit(3);
}
inline void LOG_DEBUG::clear_bug_level() {
  bug_level_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 LOG_DEBUG::bug_level() const {
  return bug_level_;
}
inline void LOG_DEBUG::set_bug_level(::google::protobuf::uint32 value) {
  _set_bit(3);
  bug_level_ = value;
}

// -------------------------------------------------------------------

// LOG_UPDATE

// optional int64 time = 1;
inline bool LOG_UPDATE::has_time() const {
  return _has_bit(0);
}
inline void LOG_UPDATE::clear_time() {
  time_ = GOOGLE_LONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::int64 LOG_UPDATE::time() const {
  return time_;
}
inline void LOG_UPDATE::set_time(::google::protobuf::int64 value) {
  _set_bit(0);
  time_ = value;
}

// optional bytes update_file = 2;
inline bool LOG_UPDATE::has_update_file() const {
  return _has_bit(1);
}
inline void LOG_UPDATE::clear_update_file() {
  if (update_file_ != &_default_update_file_) {
    update_file_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& LOG_UPDATE::update_file() const {
  return *update_file_;
}
inline void LOG_UPDATE::set_update_file(const ::std::string& value) {
  _set_bit(1);
  if (update_file_ == &_default_update_file_) {
    update_file_ = new ::std::string;
  }
  update_file_->assign(value);
}
inline void LOG_UPDATE::set_update_file(const char* value) {
  _set_bit(1);
  if (update_file_ == &_default_update_file_) {
    update_file_ = new ::std::string;
  }
  update_file_->assign(value);
}
inline ::std::string* LOG_UPDATE::mutable_update_file() {
  _set_bit(1);
  if (update_file_ == &_default_update_file_) {
    update_file_ = new ::std::string;
  }
  return update_file_;
}

// optional uint32 file_type = 3;
inline bool LOG_UPDATE::has_file_type() const {
  return _has_bit(2);
}
inline void LOG_UPDATE::clear_file_type() {
  file_type_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 LOG_UPDATE::file_type() const {
  return file_type_;
}
inline void LOG_UPDATE::set_file_type(::google::protobuf::uint32 value) {
  _set_bit(2);
  file_type_ = value;
}

// optional uint32 breboot = 4;
inline bool LOG_UPDATE::has_breboot() const {
  return _has_bit(3);
}
inline void LOG_UPDATE::clear_breboot() {
  breboot_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 LOG_UPDATE::breboot() const {
  return breboot_;
}
inline void LOG_UPDATE::set_breboot(::google::protobuf::uint32 value) {
  _set_bit(3);
  breboot_ = value;
}

// optional bool bsuccess = 5;
inline bool LOG_UPDATE::has_bsuccess() const {
  return _has_bit(4);
}
inline void LOG_UPDATE::clear_bsuccess() {
  bsuccess_ = false;
  _clear_bit(4);
}
inline bool LOG_UPDATE::bsuccess() const {
  return bsuccess_;
}
inline void LOG_UPDATE::set_bsuccess(bool value) {
  _set_bit(4);
  bsuccess_ = value;
}

// -------------------------------------------------------------------

// LOG_SHEID

// optional uint64 time = 1;
inline bool LOG_SHEID::has_time() const {
  return _has_bit(0);
}
inline void LOG_SHEID::clear_time() {
  time_ = GOOGLE_ULONGLONG(0);
  _clear_bit(0);
}
inline ::google::protobuf::uint64 LOG_SHEID::time() const {
  return time_;
}
inline void LOG_SHEID::set_time(::google::protobuf::uint64 value) {
  _set_bit(0);
  time_ = value;
}

// optional int32 block_pc_ip = 2;
inline bool LOG_SHEID::has_block_pc_ip() const {
  return _has_bit(1);
}
inline void LOG_SHEID::clear_block_pc_ip() {
  block_pc_ip_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 LOG_SHEID::block_pc_ip() const {
  return block_pc_ip_;
}
inline void LOG_SHEID::set_block_pc_ip(::google::protobuf::int32 value) {
  _set_bit(1);
  block_pc_ip_ = value;
}

// optional uint32 attack_times = 3;
inline bool LOG_SHEID::has_attack_times() const {
  return _has_bit(2);
}
inline void LOG_SHEID::clear_attack_times() {
  attack_times_ = 0u;
  _clear_bit(2);
}
inline ::google::protobuf::uint32 LOG_SHEID::attack_times() const {
  return attack_times_;
}
inline void LOG_SHEID::set_attack_times(::google::protobuf::uint32 value) {
  _set_bit(2);
  attack_times_ = value;
}

// optional uint32 attack_type = 4;
inline bool LOG_SHEID::has_attack_type() const {
  return _has_bit(3);
}
inline void LOG_SHEID::clear_attack_type() {
  attack_type_ = 0u;
  _clear_bit(3);
}
inline ::google::protobuf::uint32 LOG_SHEID::attack_type() const {
  return attack_type_;
}
inline void LOG_SHEID::set_attack_type(::google::protobuf::uint32 value) {
  _set_bit(3);
  attack_type_ = value;
}

// optional bytes reason_id = 5;
inline bool LOG_SHEID::has_reason_id() const {
  return _has_bit(4);
}
inline void LOG_SHEID::clear_reason_id() {
  if (reason_id_ != &_default_reason_id_) {
    reason_id_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& LOG_SHEID::reason_id() const {
  return *reason_id_;
}
inline void LOG_SHEID::set_reason_id(const ::std::string& value) {
  _set_bit(4);
  if (reason_id_ == &_default_reason_id_) {
    reason_id_ = new ::std::string;
  }
  reason_id_->assign(value);
}
inline void LOG_SHEID::set_reason_id(const char* value) {
  _set_bit(4);
  if (reason_id_ == &_default_reason_id_) {
    reason_id_ = new ::std::string;
  }
  reason_id_->assign(value);
}
inline ::std::string* LOG_SHEID::mutable_reason_id() {
  _set_bit(4);
  if (reason_id_ == &_default_reason_id_) {
    reason_id_ = new ::std::string;
  }
  return reason_id_;
}


}  // namespace netmon
#endif  // PROTOBUF_netmonlog_2eproto__INCLUDED
